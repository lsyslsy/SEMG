/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : usb_descriptor.c
**     Project   : ProcessorExpert
**     Processor : MKL25Z128LK4
**     Component : USB_AUDIO_CLASS
**     Version   : Driver 01.00, CPU db: 3.00.000
**     Compiler  : CodeWarrior ARM C Compiler
**     Abstract  :
**     Settings  :
**     (c) Copyright <company/user-name>, 2011
**     http      : www.<company>.com
**     mail      : info@<company>.com
** ###################################################################*/
/******************************************************************************
* Includes
*****************************************************************************/
#include "types.h"
#include "usb_class.h"
#include "usb_descriptor.h"
#include "usb_framework.h"
#include <stdlib.h>
#include <string.h>

/*****************************************************************************
* Constant and Macro's
*****************************************************************************/
/* structure containing details of all the endpoints used by this device */
const USB_ENDPOINTS usb_desc_ep ={
    AUDIO_DESC_ENDPOINT_COUNT,
    {
        {
            1,
            USB_ISOCHRONOUS_PIPE,
            USB_SEND,
            256,
        },
    }
};

/* *********************************************************************
* definition a struct of Input/output or Feature Unit
************************************************************************ */
/* Struct of Terminal Input /Output or Feature Unit */
 USB_AUDIO_UNITS usb_audio_unit = {
    AUDIO_UNIT_COUNT,
    {
        {0x01,AUDIO_CONTROL_INPUT_TERMINAL},
        {0x02,AUDIO_CONTROL_FEATURE_UNIT},
        {0x03,AUDIO_CONTROL_OUTPUT_TERMINAL},
    }
};

/* Device Descriptor */
uint_8 g_device_descriptor[DEVICE_DESCRIPTOR_SIZE]=
{
    DEVICE_DESCRIPTOR_SIZE,            /* Device Descriptor Size         */
    USB_DEVICE_DESCRIPTOR,             /* Device Type of descriptor      */
    0x00, 0x02,                        /* BCD USB version                */
    0x00,                              /* Device Class is indicated inthe interface descriptors      */
    0x00,                              /* Device Subclass is indicated
                                       in the interface descriptors   */
    0x00,                              /* Device Protocol                */
    0x20,                              /* Max Packet size                */
    0xA2, 0x15,                        /* Vendor ID                      */
    0x05,0x02,                         /* Product ID  */
    0x02, 0x00,                        /* BCD Device version             */
    0x01 ,                             /* Manufacturer string index      */
    0x02 ,                             /* Product string index           */
    0x03 ,                             /* Serial number string index     */
    0x01                               /* Number of configurations       */
};

/* Configuration Descriptor */
uint_8 g_config_descriptor[CONFIG_DESC_SIZE] =
{
    CONFIG_ONLY_DESC_SIZE,             /* Configuration Descriptor Size */
    USB_CONFIG_DESCRIPTOR,             /* Configuration type of descriptor */
    USB_uint_16_low(CONFIG_DESC_SIZE),USB_uint_16_high(CONFIG_DESC_SIZE), /* Total length of the Configuration descriptor */
    0x02,                              /* NumInterfaces*/
    0x01,                              /* Configuration Value */
    0x00,                              /* Configuration Description String Index*/
    (BUS_POWERED | SELF_POWERED),      /* Attributes.support RemoteWakeup and self power*/
    0x32,                              /* Current draw from bus*/
    /* AUDIO CONTROL INTERFACE DESCRIPTOR */
    /* Standard Audio Control Interface Descriptor */
    IFACE_ONLY_DESC_SIZE,              /* Size of this descriptor */
    USB_IFACE_DESCRIPTOR,              /* INTERFACE descriptor type */
    0x00,                              /* Number of interface */
    0x00,                              /* Alternate Setting value */
    0x00,                              /* Number of endpoints */
    0x01,                              /* Interface Class */
    0x01,                              /* Interface Sub Class */
    0x00,                              /* Interface Protocol */
    0x00,                              /* Index of a string descriptor */


    /* Class-specific Audio Control Interface Descriptor */
    HEADER_ONLY_DESC_SIZE,             /* Size of this descriptor */
    AUDIO_INTERFACE_DESCRIPTOR_TYPE,   /* Interface descriptor type */
    AUDIO_CONTROL_HEADER,              /* Interface descriptor sub type */
    0x00,0x01,                         /* bcdADC */
    0x29,0x00,                         /* Total Length */
    0x01,                              /* Interface collection */
    0x01,                              /* Interface Number */

    /* Input Terminal 0 Descriptor */
    INPUT_TERMINAL_ONLY_DESC_SIZE,     /* Size of this descriptor */
    AUDIO_INTERFACE_DESCRIPTOR_TYPE,   /* Interface descriptor type */
    AUDIO_CONTROL_INPUT_TERMINAL,      /* Interface descriptor sub type */
    0x01,                              /* Input TerminalID */
    0x01,0x02,                         /* Terminal Type */
    0x00,                              /* Association Terminal */
    0x01,                              /* Number of logical output channel */
    0x00,0x00,                         /* Channel configuration */
    0x00,                              /* Channel Name */
    0x00,                              /* Index of input terminal string */

    /* Feature Unit 0 Descriptor */
    0x0B,                              /* Size of this descriptor */
    AUDIO_INTERFACE_DESCRIPTOR_TYPE,   /* Interface descriptor type */
    AUDIO_CONTROL_FEATURE_UNIT,        /* Interface descriptor sub type */
    0x02,                              /* Feature UnitID */
    0x01,                              /* Feature Unit SourceID */
    0x02,                              /* Control size */
    /* Enable control for channel 0 */
    USB_uint_16_low(
    AUDIO_MUTE_CONTROL |
    AUDIO_VOLUME_CONTROL |
    AUDIO_BASS_CONTROL |
    AUDIO_MID_CONTROL |
    AUDIO_TREBLE_CONTROL |
    AUDIO_GRAPHIC_EQ_CONTROL |
    AUDIO_AUTOMATIC_GAIN_CONTROL |
    AUDIO_DELAY_CONTROL |
    AUDIO_BASS_BOOST_CONTROL |
    AUDIO_LOUDNESS_CONTROL |
    0
    ),
    USB_uint_16_high(
    AUDIO_MUTE_CONTROL |
    AUDIO_VOLUME_CONTROL |
    AUDIO_BASS_CONTROL |
    AUDIO_MID_CONTROL |
    AUDIO_TREBLE_CONTROL |
    AUDIO_GRAPHIC_EQ_CONTROL |
    AUDIO_AUTOMATIC_GAIN_CONTROL |
    AUDIO_DELAY_CONTROL |
    AUDIO_BASS_BOOST_CONTROL |
    AUDIO_LOUDNESS_CONTROL |
    0
    ),
    /* Enable control for channel 1 */
    USB_uint_16_low(
    0
    ),
    USB_uint_16_high(
    0
    ),
    0x00,                              /* Index of feature unit string */

    /* Output Terminal 0 Descriptor */
    OUTPUT_TERMINAL_ONLY_DESC_SIZE,    /* Size of this descriptor */
    AUDIO_INTERFACE_DESCRIPTOR_TYPE,   /* Interface descriptor type */
    AUDIO_CONTROL_OUTPUT_TERMINAL,     /* Interface descriptor sub type */
    0x03,                              /* Output TerminalID */
    0x01,0x01,                         /* Output Terminal Type */
    0x00,                              /* Association Terminal */
    0x02,                              /* SourceID */
    0x00,                              /* Index of output terminal string */

    /* AUDIO STREM INTERFACE DESCRIPTOR */
    /* Standard AS interface descriptor */
    /* Alternate setting 0 */
    IFACE_ONLY_DESC_SIZE,              /* Size of this descriptor */
    USB_IFACE_DESCRIPTOR,              /* Descriptor type */
    0x01,                              /* Interface number */
    0x00,                              /* Alternate setting */
    0x00,                              /* Number endpoints */
    0x01,                              /* Interface class */
    0x02,                              /* Interface sub class */
    0x00,                              /* Interface protocol */
    0x00,                              /* Interface index string */

    /* Alternate setting 1 */
    IFACE_ONLY_DESC_SIZE,              /* Size of this descriptor */
    USB_IFACE_DESCRIPTOR,              /* Descriptor type */
    0x01,                              /* Interface number */
    0x01,                              /* Alternate setting */
    0x01,                              /* Number endpoints */
    0x01,                              /* Interface class */
    0x02,                              /* Interface sub class */
    0x00,                              /* Interface protocol */
    0x00,                              /* Interface index string */

    /* Class-Specific AS Interface Descriptor */
    AUDIO_STREAMING_IFACE_DESC_SIZE,   /* Size of descriptor */
    AUDIO_INTERFACE_DESCRIPTOR_TYPE,   /* Descriptor type */
    AUDIO_STREAMING_GENERAL,           /* Descriptor sub type */
    0x03,                              /* Terminal Link */
    0x00,                              /* Delay */
    0x02,0x00,                         /* Format tag */

    /* Type I format type interface descriptor */
    AUDIO_INTERFACE_DESC_TYPE_I_SIZE,  /* Size of this descriptor */
    AUDIO_INTERFACE_DESCRIPTOR_TYPE,   /* Interface Descriptor type */
    AUDIO_STREAMING_FORMAT_TYPE,       /* Interface descriptor sub type */
    AUDIO_FORMAT_TYPE_I,               /* Format type */
    0x01,                              /* Number channel */
    0x01,                              /* Frame size */
    0x08,                              /* Bit resolution */
    0x01,                              /* One Sampling frequency */
    0x40,0x1F,0x00,                    /* Sampling frequency */

    /* Standard AS Data Endpoint Descriptor */
    ENDP_ONLY_DESC_SIZE,               /* Size of this descriptor */
    USB_ENDPOINT_DESCRIPTOR,           /* Descriptor type */
    0x81,                              /* Endpoint address */
    0x01,                              /* Attribute */
    0x00,0x01,                         /* Endpoint max packet size */
    0x01,                              /* Interval */
    0x00,                              /* Refresh */
    0x00,                              /* SyncAddress */

    /*Class-Specific AS Data Endpoint Descriptor */
    AUDIO_STREAMING_ENDP_DESC_SIZE,    /* Size of this descriptor */
    USB_AUDIO_DESCRIPTOR,              /* Descriptor type */
    AUDIO_ENDPOINT_GENERAL,            /* Descriptor sub type */
    0x00,                              /* attribute */
    0x00,                              /* Lock delay unit*/
    0x00,0x00,                         /* Lock delay */

};

/* String 0 Descriptor */
uint_8 USB_STR_0[USB_STR_0_SIZE+USB_STR_DESC_SIZE] = {
    sizeof(USB_STR_0),
    USB_STRING_DESCRIPTOR,
    0x09,
    0x04                               /*equiavlent to 0x0409*/
};

uint_8 USB_STR_1[USB_STR_1_SIZE+USB_STR_DESC_SIZE] = {
    sizeof(USB_STR_1),
    USB_STRING_DESCRIPTOR,
    'F',0,
    'R',0,
    'E',0,
    'E',0,
    'S',0,
    'C',0,
    'A',0,
    'L',0,
    'E',0,
    ' ',0,
    'S',0,
    'E',0,
    'M',0,
    'I',0,
    'C',0,
    'O',0,
    'N',0,
    'D',0,
    'U',0,
    'C',0,
    'T',0,
    'O',0,
    'R',0,
    ' ',0,
    'I',0,
    'N',0,
    'C',0,
    '.',0,
};
uint_8 USB_STR_2[USB_STR_2_SIZE+USB_STR_DESC_SIZE] = {
    sizeof(USB_STR_2),
    USB_STRING_DESCRIPTOR,
    'U',0,
    'S',0,
    'B',0,
    ' ',0,
    'A',0,
    'U',0,
    'D',0,
    'I',0,
    'O',0,
    ' ',0,
    'D',0,
    'E',0,
    'V',0,
    'I',0,
    'C',0,
    'E',0,
    ' ',0,
    'P',0,
    'E',0,
    'x',0,
    ' ',0,
    'D',0,
    'E',0,
    'M',0,
    'O',0,
};

uint_8 USB_STR_n[USB_STR_n_SIZE+USB_STR_DESC_SIZE] = {
    sizeof(USB_STR_n),
    USB_STRING_DESCRIPTOR,
    'B',0,
    'A',0,
    'D',0,
    ' ',0,
    'S',0,
    'T',0,
    'R',0,
    'I',0,
    'N',0,
    'G',0,
    ' ',0,
    'I',0,
    'N',0,
    'D',0,
    'E',0,
    'X',0
};

USB_PACKET_SIZE const g_std_desc_size[USB_MAX_STD_DESCRIPTORS+1] = {
    0,
    DEVICE_DESCRIPTOR_SIZE,
    CONFIG_DESC_SIZE,
    0, /* string */
    0, /* Interface */
    0, /* Endpoint */
    0, /* Device Qualifier */
    0, /* other speed config */
    0
};

uint_8_ptr const g_std_descriptors[USB_MAX_STD_DESCRIPTORS+1] = {
    NULL,
    (uint_8_ptr)g_device_descriptor,
    (uint_8_ptr)g_config_descriptor,
    NULL, /* string */
    NULL, /* Interface */
    NULL, /* Endpoint */
    NULL, /* Device Qualifier */
    NULL, /* other speed config*/
    NULL
};

uint_8 const g_string_desc_size[USB_MAX_STRING_DESCRIPTORS+1] = {
    sizeof(USB_STR_0),
    sizeof(USB_STR_1),
    sizeof(USB_STR_2),
    sizeof(USB_STR_n)
};

uint_8_ptr const g_string_descriptors[USB_MAX_STRING_DESCRIPTORS+1] = {
    (uint_8_ptr const)USB_STR_0,
    (uint_8_ptr const)USB_STR_1,
    (uint_8_ptr const)USB_STR_2,
    (uint_8_ptr const)USB_STR_n
};

USB_ALL_LANGUAGES g_languages = {
    USB_STR_0, sizeof(USB_STR_0),
    {
        {
            (uint_16 const)0x0409,
            (const uint_8 **)g_string_descriptors,
            g_string_desc_size
        }
    }
};

uint_8 const g_valid_config_values[USB_MAX_CONFIG_SUPPORTED+1]={0,1};

/****************************************************************************
* Public Variables
****************************************************************************/
/* Current mute variables */
uint_8 g_cur_mute[USB_MAX_SUPPORTED_INTERFACES] ={0x00};

/****************************************************************************
* Internal Variables
****************************************************************************/
static uint_8 g_alternate_interface[USB_MAX_SUPPORTED_INTERFACES];

/* Current pitch variables */
static uint_8 g_cur_pitch = 0x01;

/* Current loudness vareables */
static uint_8 g_cur_loudness[USB_MAX_SUPPORTED_INTERFACES] = {0x01};

/* Current bass boost variables */
static uint_8 g_cur_bass_boost[USB_MAX_SUPPORTED_INTERFACES] = {0x01};

/* Current automatic gain variables */
static uint_8 g_cur_automatic_gain[USB_MAX_SUPPORTED_INTERFACES] = {0x01};

/* Copy protect variables */
static uint_8 g_copy_protect[USB_MAX_SUPPORTED_INTERFACES]={0x01};

/* Volume variables */
static uint_8 g_cur_volume[USB_MAX_SUPPORTED_INTERFACES][2] = {{0x00,0x80}};
static uint_8 g_min_volume[USB_MAX_SUPPORTED_INTERFACES][2] = {{0x00,0x80}};
static uint_8 g_max_volume[USB_MAX_SUPPORTED_INTERFACES][2] = {{0xFF,0x7F}};
static uint_8 g_res_volume[USB_MAX_SUPPORTED_INTERFACES][2] = {{0x01,0x00}};

/* Bass variables */
static uint_8 g_cur_bass[USB_MAX_SUPPORTED_INTERFACES] = {0x00};
static uint_8 g_min_bass[USB_MAX_SUPPORTED_INTERFACES] = {0x80};
static uint_8 g_max_bass[USB_MAX_SUPPORTED_INTERFACES] = {0x7F};
static uint_8 g_res_bass[USB_MAX_SUPPORTED_INTERFACES] = {0x01};

/* Mid variables */
static uint_8 g_cur_mid[USB_MAX_SUPPORTED_INTERFACES] = {0x00};
static uint_8 g_min_mid[USB_MAX_SUPPORTED_INTERFACES] = {0x80};
static uint_8 g_max_mid[USB_MAX_SUPPORTED_INTERFACES] = {0x7F};
static uint_8 g_res_mid[USB_MAX_SUPPORTED_INTERFACES] = {0x01};

/* Treble variables */
static uint_8 g_cur_treble[USB_MAX_SUPPORTED_INTERFACES] = {0x01};
static uint_8 g_min_treble[USB_MAX_SUPPORTED_INTERFACES] = {0x80};
static uint_8 g_max_treble[USB_MAX_SUPPORTED_INTERFACES] = {0x7F};
static uint_8 g_res_treble[USB_MAX_SUPPORTED_INTERFACES] = {0x01};

/* Graphic equalizer variables */
static uint_8 g_cur_graphic_equalizer[USB_MAX_SUPPORTED_INTERFACES][5] = {{0x00,0x00,0x00,0x00,0x00}};
static uint_8 g_min_graphic_equalizer[USB_MAX_SUPPORTED_INTERFACES][5] = {{0x00,0x00,0x00,0x00,0x00}};
static uint_8 g_max_graphic_equalizer[USB_MAX_SUPPORTED_INTERFACES][5] = {{0x00,0x00,0x00,0x00,0x00}};
static uint_8 g_res_graphic_equalizer[USB_MAX_SUPPORTED_INTERFACES][5] = {{0x00,0x00,0x00,0x00,0x00}};

/* Delay variables */
static uint_8 g_cur_delay[USB_MAX_SUPPORTED_INTERFACES][2] = {{0x00,0x40}};
static uint_8 g_min_delay[USB_MAX_SUPPORTED_INTERFACES][2] = {{0x00,0x00}};
static uint_8 g_max_delay[USB_MAX_SUPPORTED_INTERFACES][2] = {{0xFF,0xFF}};
static uint_8 g_res_delay[USB_MAX_SUPPORTED_INTERFACES][2] = {{0x00,0x01}};

/* Sampling frequency variables */
static uint_8 g_cur_sampling_frequency[3] = {0x00,0x00,0x01};
static uint_8 g_min_sampling_frequency[3] = {0x00,0x00,0x00};
static uint_8 g_max_sampling_frequency[3] = {0x7F,0xFF,0xFF};
static uint_8 g_res_sampling_frequency[3] = {0x00,0x01,0x00};

/* Status endpoint data */
static uint_8 status_endpoint_data[5] = {0x01, 0x02, 0x03, 0x04, 0x05};

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function returns the correponding descriptor
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         type            - 
**         str_num         - 
**         index           - 
**       * descriptor      - Pointer to descriptor 
**       * size            - Pointer to 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Descriptor(
uint_8 controller_ID,
uint_8 type,
uint_8 str_num,
uint_16 index,
uint_8_ptr *descriptor,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    switch(type)
    {
    case USB_REPORT_DESCRIPTOR:
        {
            type = USB_MAX_STD_DESCRIPTORS;
            *descriptor = (uint_8_ptr)g_std_descriptors [type];
            *size = g_std_desc_size[type];
        }
        break;
    case USB_AUDIO_DESCRIPTOR:
        {
            type = USB_CONFIG_DESCRIPTOR ;
            *descriptor = (uint_8_ptr)(g_std_descriptors [type]+
            CONFIG_ONLY_DESC_SIZE+IFACE_ONLY_DESC_SIZE);
            *size = AUDIO_ONLY_DESC_SIZE;
        }
        break;
    case USB_STRING_DESCRIPTOR:
        {
            if(index == 0)
            {
                /* return the string and size of all languages */
                *descriptor = (uint_8_ptr)g_languages.
                languages_supported_string;
                *size = g_languages.languages_supported_size;
            } else
            {
                uint_8 lang_id=0;
                uint_8 lang_index=USB_MAX_LANGUAGES_SUPPORTED;

                for(;lang_id< USB_MAX_LANGUAGES_SUPPORTED;lang_id++)
                {
                    /* check whether we have a string for this language */
                    if(index == g_languages.usb_language[lang_id].language_id)
                    {   /* check for max descriptors */
                        if(str_num < USB_MAX_STRING_DESCRIPTORS)
                        {   /* setup index for the string to be returned */
                            lang_index=str_num;
                        }
                        break;
                    }
                }

                /* set return val for descriptor and size */
                *descriptor = (uint_8_ptr)g_languages.usb_language[lang_id].
                lang_desc[lang_index];
                *size = g_languages.usb_language[lang_id].
                lang_desc_size[lang_index];
            }
        }
        break;
        default :
        if (type < USB_MAX_STD_DESCRIPTORS)
        {
            /* set return val for descriptor and size*/
            *descriptor = (uint_8_ptr)g_std_descriptors [type];

            /* if there is no descriptor then return error */
            if(*descriptor == NULL)
            {
                return USBERR_INVALID_REQ_TYPE;
            }
            *size = g_std_desc_size[type];
        }
        else /* invalid descriptor */
        {
            return USBERR_INVALID_REQ_TYPE;
        }
        break;
    }
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function returns the alternate interface
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**         alt_interface   - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Interface(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr alt_interface
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES)
    {
        /* get alternate interface*/
        *alt_interface = g_alternate_interface[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets the alternate interface
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**         alt_interface   - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Interface(
uint_8 controller_ID,
uint_8 interface,
uint_8 alt_interface
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES)
    {
        /* set alternate interface*/
        g_alternate_interface[interface] = alt_interface;
        return USB_OK;
    }

    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function checks whether the configuration parameter
**         input is valid or not
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         config_val      - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
boolean USB_Desc_Valid_Configation(
uint_8 controller_ID,
uint_16 config_val
)
{
    uint_8 loop_index=0;

    UNUSED (controller_ID);
    /* check with only supported val right now */
    while(loop_index < (USB_MAX_CONFIG_SUPPORTED+1))
    {
        if(config_val == g_valid_config_values[loop_index])
        {
            return TRUE;
        }
        loop_index++;
    }
    return FALSE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function checks whether the interface parameter input is
**         valid or not
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
boolean USB_Desc_Valid_Interface(
uint_8 controller_ID,
uint_8 interface
)
{
    uint_8 loop_index=0;
    UNUSED (controller_ID);
    /* check with only supported val right now */
    while(loop_index < USB_MAX_SUPPORTED_INTERFACES)
    {
        if(interface == g_alternate_interface[loop_index])
        {
            return TRUE;
        }
        loop_index++;
    }
    return FALSE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function checks whether the remote wakeup is supported
**         or not
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
boolean USB_Desc_Remote_Wakeup(uint_8 controller_ID)
{
    UNUSED (controller_ID);
    return REMOTE_WAKEUP_SUPPORT;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function returns with the list of all non control
**         endpoints used
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
void* USB_Desc_Get_Endpoints(
uint_8 controller_ID
)
{
    UNUSED (controller_ID);
    return (void*)&usb_desc_ep;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function returns with the list of all Input Terminal,
**         Output Terminal and Feature Unit
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
void* USB_Desc_Get_Entities(
uint_8 controller_ID
)
{
    UNUSED (controller_ID);
    return (void*)&usb_audio_unit;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function is called in response to Set Terminal Control
**         Request
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Copy_Protect(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set copy protect data*/
        g_copy_protect[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function is called in response to Get Terminal Control
**         Request
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Copy_Protect(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get copy protect data*/
        *size=1;
        *data=&g_copy_protect[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Mute state
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Mute(uint_8 controller_ID, uint_8 interface, uint_8_ptr *data, USB_PACKET_SIZE *size)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current mute data*/
        g_cur_mute[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the current Mute state
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Mute(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current mute data*/
        *size = 1;
        *data = &g_cur_mute[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Volume value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Volume(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    int_16 volume;
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current volume data*/
        g_cur_volume[interface][0] = **data;
        g_cur_volume[interface][1] = *(*data+1);
        volume = (int_16)((g_cur_volume[interface][1] << 8) | g_cur_volume[interface][0]);
        /* The current volume is received as logical value
    * Logical  S16:  0x8000      to 0x7FFF             and corresponds to
    * Physical      -127.9661 dB to 127.9661 dB
    * The equation for the line that passes through the above coordinates results:
    *  y = 0.0039*x - 3.1
    */
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Minimum Volume value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Min_Volume(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set min volume data*/
        g_min_volume[interface][0] = **data;
        g_min_volume[interface][1] = *(*data+1);
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Maximum Volume value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Max_Volume(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set max volume data*/
        g_max_volume[interface][0] = **data;
        g_max_volume[interface][1] = *(*data+1);
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Resolution Volume value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Res_Volume(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set resolution volume data*/
        g_res_volume[interface][0] = **data;
        g_res_volume[interface][1] = *(*data+1);
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Current Volume value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Volume(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current volume data*/
        *size = 2;
        *data = g_cur_volume[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Minimum Volume value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Min_Volume(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get min volume data*/
        *size = 2;
        *data = g_min_volume[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Maximum Volume value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Max_Volume(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* Get max volume data*/
        *size = 2;
        *data = g_max_volume[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Resolution Volume value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Res_Volume(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* Get resolution volume data*/
        *size = 2;
        *data = g_res_volume[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Bass value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Bass(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current bass data*/
        g_cur_bass[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Minimum Bass value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Min_Bass(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set min bass data*/
        g_min_bass[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Maximum Bass value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Max_Bass(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set max bass data*/
        g_max_bass[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Resolution Bass value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Res_Bass(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set resolution bass data*/
        g_res_bass[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Current Bass value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Bass(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current bass data*/
        *size = 1;
        *data = &g_cur_bass[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Minimum Bass value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Min_Bass(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get min bass data*/
        *size = 1;
        *data = &g_min_bass[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Maximum Bass value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Max_Bass(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get max bass data*/
        *size = 1;
        *data = &g_max_bass[interface];
        return USB_OK;
    }

    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Maximum Bass value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Res_Bass(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get resolution bass data*/
        *size = 1;
        *data = &g_res_bass[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Mid value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Mid(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current mid data*/
        g_cur_mid[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         This function is called to Set Minimum Mid value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Min_Mid(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set min mid data*/
        g_min_mid[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         This function is called to Set Maximum Mid value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Max_Mid(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set max mid data*/
        g_max_mid[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         This function is called to Set Maximum Mid value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Res_Mid(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set resolution mid data*/
        g_res_mid[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Current Mid value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Mid(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current Mid data*/
        *size = 1;
        *data=&g_cur_mid[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Minimum Mid value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Min_Mid(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface<USB_MAX_SUPPORTED_INTERFACES){
        /* get min mid data data*/
        *size = 1;
        *data = &g_min_mid[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Maximum Mid value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Max_Mid(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface<USB_MAX_SUPPORTED_INTERFACES){
        /* get max mid data data*/
        *size = 1;
        *data = &g_max_mid[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets the Resolution Mid value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Res_Mid(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface<USB_MAX_SUPPORTED_INTERFACES){
        /* get resolution mid data data*/
        *size = 1;
        *data = &g_res_mid[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function set Current Treble value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Treble(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current treble data*/
        g_cur_treble[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function set Current Treble value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Min_Treble(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set min treble data*/
        g_min_treble[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function set Current Treble value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Max_Treble(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set max treble data*/
        g_max_treble[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function set Resolution Treble value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Res_Treble(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set resolution treble data*/
        g_res_treble[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function get Current Treble value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Treble(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current treble data*/
        *size=1;
        *data=&g_cur_treble[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function get Minimum Treble value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Min_Treble(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get min treble data*/
        *size=1;
        *data=&g_min_treble[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function get Maximum Treble value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Max_Treble(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get max treble data*/
        *size=1;
        *data=&g_max_treble[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Resolution Treble value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Res_Treble(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get resolution treble data*/
        *size=1;
        *data=&g_res_treble[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Graphic Equalizer values
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Graphic_Equalizer(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current graphic equalizer data*/
        g_cur_graphic_equalizer[interface][0] = **data;
        g_cur_graphic_equalizer[interface][1] = *(*data+1);
        g_cur_graphic_equalizer[interface][2] = *(*data+2);
        g_cur_graphic_equalizer[interface][3] = *(*data+3);
        g_cur_graphic_equalizer[interface][4] = *(*data+4);
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Minimum Graphic Equalizer values
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Min_Graphic_Equalizer(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set min graphic equalizer data*/
        g_min_graphic_equalizer[interface][0] = **data;
        g_min_graphic_equalizer[interface][1] = *(*data+1);
        g_min_graphic_equalizer[interface][2] = *(*data+2);
        g_min_graphic_equalizer[interface][3] = *(*data+3);
        g_min_graphic_equalizer[interface][4] = *(*data+4);
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Maximum Graphic Equalizer values
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Max_Graphic_Equalizer(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set max graphic equalizer data*/
        g_max_graphic_equalizer[interface][0] = **data;
        g_max_graphic_equalizer[interface][1] = *(*data+1);
        g_max_graphic_equalizer[interface][2] = *(*data+2);
        g_max_graphic_equalizer[interface][3] = *(*data+3);
        g_max_graphic_equalizer[interface][4] = *(*data+4);
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Resolution Graphic Equalizer values
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Res_Graphic_Equalizer(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set resolution graphic equalizer data*/
        g_res_graphic_equalizer[interface][0] = **data;
        g_res_graphic_equalizer[interface][1] = *(*data+1);
        g_res_graphic_equalizer[interface][2] = *(*data+2);
        g_res_graphic_equalizer[interface][3] = *(*data+3);
        g_res_graphic_equalizer[interface][4] = *(*data+4);
        return USB_OK;
    }

    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Current Graphic Equalizer values
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Graphic_Equalizer(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current graphic equalizer data*/
        *size=5;
        *data=g_cur_graphic_equalizer[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Minimum Graphic Equalizer values
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Min_Graphic_Equalizer(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get min graphic equalizer data*/
        *size=5;
        *data=g_min_graphic_equalizer[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Maximum Graphic Equalizer values
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Max_Graphic_Equalizer(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get max graphic equalizer data*/
        *size=5;
        *data=g_max_graphic_equalizer[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Resolution Graphic Equalizer values
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Res_Graphic_Equalizer(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get resolution graphic equalizer data*/
        *size=5;
        *data=g_res_graphic_equalizer[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Automatic Gain value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Automatic_Gain(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current automatic data*/
        g_cur_automatic_gain[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Current Automatic Gain value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Automatic_Gain(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current automatic data*/
        *size=1;
        *data=&g_cur_automatic_gain[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Delay value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Delay(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current delay data*/
        g_cur_delay[interface][0] = **data;
        g_cur_delay[interface][1] = *(*data+1);
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Minimum Delay value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Min_Delay(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set min delay data*/
        g_min_delay[interface][0] = **data;
        g_min_delay[interface][1] = *(*data+1);
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Maximum Delay value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Max_Delay(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set max delay data*/
        g_max_delay[interface][0] = **data;
        g_max_delay[interface][1] = *(*data+1);

        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Resolution Delay value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Res_Delay(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set resolution delay data*/
        g_res_delay[interface][0] = **data;
        g_res_delay[interface][1] = *(*data+1);
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Current Delay value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Delay(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current delay data*/
        *size=2;
        *data=g_cur_delay[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Minimum Delay value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Min_Delay(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get min delay data*/
        *size=2;
        *data=g_min_delay[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Maximum Delay value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Max_Delay(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get max delay data*/
        *size=2;
        *data=g_max_delay[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Resolution Delay value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Res_Delay(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get resolution delay data*/
        *size=2;
        *data=g_res_delay[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Bass Boost value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Bass_Boost(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current bass boost data*/
        g_cur_bass_boost[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Current Bass Boost value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Bass_Boost(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current bass boost data*/
        *size=1;
        *data=&g_cur_bass_boost[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Loudness value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Loudness(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* set current loudness data*/
        g_cur_loudness[interface] = **data;
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Loudness value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Loudness(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    /* if interface valid */
    if(interface < USB_MAX_SUPPORTED_INTERFACES){
        /* get current loudness data*/
        *size=1;
        *data=&g_cur_loudness[interface];
        return USB_OK;
    }
    return USBERR_INVALID_REQ_TYPE;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Sampling Frequency value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Sampling_Frequency(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    UNUSED (interface);
    /* set current sampling fequency data*/
    g_cur_sampling_frequency[0] = **data;
    g_cur_sampling_frequency[1] = *(*data+1);
    g_cur_sampling_frequency[2] = *(*data+2);
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Current Sampling Frequency value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Min_Sampling_Frequency(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    UNUSED (interface);
    /* set min sampling frequency data*/
    g_min_sampling_frequency[0] = **data;
    g_min_sampling_frequency[1] = *(*data+1);
    g_min_sampling_frequency[2] = *(*data+2);
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Maximum Sampling Frequency value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Max_Sampling_Frequency(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    UNUSED (interface);
    /* set max sampling frequency data*/
    g_max_sampling_frequency[0] = **data;
    g_max_sampling_frequency[1] = *(*data+1);
    g_max_sampling_frequency[2] = *(*data+2);
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function sets Resolution Sampling Frequency value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Res_Sampling_Frequency(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    UNUSED (interface);
    /* set resolution sampling frequency data*/
    g_res_sampling_frequency[0] = **data;
    g_res_sampling_frequency[1] = *(*data+1);
    g_res_sampling_frequency[2] = *(*data+2);
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Current Sampling Frequency value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Sampling_Frequency(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (interface);
    /* get current sampling frequency data*/
    *size=3;
    *data=g_cur_sampling_frequency;
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Minimum Sampling Frequency value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Min_Sampling_Frequency(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (interface);
    /* get min sampling frequency data*/
    *size=3;
    *data=g_min_sampling_frequency;
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Minimum Sampling Frequency value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Max_Sampling_Frequency(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (interface);
    /* get max sampling frequency data*/
    *size=3;
    *data=g_max_sampling_frequency;
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Resolution Sampling Frequency value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Res_Sampling_Frequency(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (interface);
    /* get resolution sampling frequency data*/
    *size=3;
    *data=g_res_sampling_frequency;
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Resolution Sampling Frequency value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Cur_Pitch(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (size);
    UNUSED (interface);
    /* set current pitch data*/
    g_cur_pitch = **data;
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets Current Pitch value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Cur_Pitch(
uint_8 controller_ID,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (interface);
    /* get current pitch data*/
    *size=1;
    *data=&g_cur_pitch;
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets endpoint memory value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         offset          - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Set_Mem_Endpoint(
uint_8 controller_ID,
uint_16 offset,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_16 index;

    UNUSED (controller_ID);
    UNUSED (interface);

    for(index = 0; index < *size ; index++)
    {   /* copy the report sent by the host */
        status_endpoint_data[offset + index] = *(*data + index);
    }
    *size = 0;

    return USB_OK;
}

/*
** ===================================================================
**     Method      :  usb_audio_ (component USB_AUDIO_CLASS)
**     Description :
**         The function gets endpoint memory value
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         offset          - 
**         interface       - 
**       * data            - Pointer to Data
**       * size            - Pointer to size of data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Desc_Get_Mem_Endpoint(
uint_8 controller_ID,
uint_16 offset,
uint_8 interface,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    UNUSED (controller_ID);
    UNUSED (interface);
    UNUSED (size);

    *data = &status_endpoint_data[offset];
    return USB_OK;
}

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.08]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
