/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : usb_audio.c
**     Project     : ProcessorExpert
**     Processor   : MKL25Z128VLK4
**     Component   : USB_AUDIO_CLASS
**     Version     : Component 01.000, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2014-10-22, 18:48, # CodeGen: 36
**     Abstract    :
**
**     Settings    :
**
**     Contents    :
**         USB_Class_Audio_Init      - uint_8 usb_audio_USB_Class_Audio_Init(uint_8 controller_ID,...
**         USB_Class_Audio_DeInit    - uint_8 usb_audio_USB_Class_Audio_DeInit(uint_8 controller_ID);
**         USB_Class_Audio_Send_Data - uint_8 usb_audio_USB_Class_Audio_Send_Data(uint_8 controller_ID, uint_8...
**         USB_Class_Audio_Recv_Data - uint_8 usb_audio_USB_Class_Audio_Recv_Data(uint_8 controller_ID, uint_8...
**
**     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
**     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/
/*!
** @file usb_audio.c
** @version 01.00
** @brief
**
*/         
/*!
**  @addtogroup usb_audio_module usb_audio module documentation
**  @{
*/         

/* MODULE usb_audio. */


#include "usb_audio.h"
#include "usb_devapi.h"   /* USB device Header File */

/****************************************************************************
* Internal Variables
****************************************************************************/
/* Audio endpoint info array */
static USB_CLASS_AUDIO_ENDPOINT_DATA g_audio_endpoint_data;
/* Audio Class Callback Function Pointer */
static USB_CLASS_CALLBACK g_audio_class_callback=NULL;
/* Audio Class Vendor Callback Function Pointer */
static USB_REQ_FUNC       g_vendor_req_callback=NULL;
/* Audio Class requests Callback Function Pointer */
static USB_CLASS_CALLBACK g_param_callback = NULL;
/*
** ===================================================================
**     Method      :  USB_Service_Audio_Status_Interrupt (component USB_AUDIO_CLASS)
**
**     Description :
**         The funtion is callback function of Audio Status Interrupt 
**         endpoint
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_Service_Audio_Status_Interrupt(
PTR_USB_DEV_EVENT_STRUCT event
)
{
    uint_8 index;
    uint_8 producer, consumer;
    USB_ENDPOINTS *usb_ep_data = (USB_ENDPOINTS *)USB_Desc_Get_Endpoints(event->controller_ID);

    /* map the endpoint num to the index of the endpoint structure */
    for(index = 0; index < usb_ep_data->count; index++)
    {
        if(usb_ep_data->ep[index].ep_num == event->ep_num)
        break;
    }

    producer = g_audio_endpoint_data.ep[index].bin_producer;
    consumer = g_audio_endpoint_data.ep[index].bin_consumer;
    /* if there are no errors de-queue the queue and decrement the no. of
    transfers left, else send the same data again */
    if (event->errors == 0)
    {
        /* de-queue if the send is complete without an error */
        if((MAX_QUEUE_ELEMS-1) == consumer)
        {
            g_audio_endpoint_data.ep[index].bin_consumer = 0;
        }
        else
        {
            g_audio_endpoint_data.ep[index].bin_consumer++;
        }
    }

    consumer = g_audio_endpoint_data.ep[index].bin_consumer;
    g_audio_endpoint_data.ep[index].queue_num--;

    if(0 == g_audio_endpoint_data.ep[index].queue_num)
    {
        /*if bin is not empty */
        USB_CLASS_AUDIO_QUEUE queue;
        /* send the next packet in queue */
        queue = g_audio_endpoint_data.ep[index].queue[consumer];
        (void)USB_Class_Send_Data(queue.controller_ID, queue.channel,
        queue.app_buff, queue.size);
    }

    if(g_param_callback != NULL)
    {
        uint_8 event_type = USB_APP_SEND_COMPLETE;
        if(event->errors != 0)
        {
            event_type = USB_APP_ERROR;
        }
        g_param_callback(event->controller_ID, event_type,
        (uint_8*)(&(event->errors)));
    }
}

/*
** ===================================================================
**     Method      :  USB_Service_Audio_Isochronous_IN (component USB_AUDIO_CLASS)
**
**     Description :
**         The funtion ic callback function of Audio Isochronous IN 
**         endpoint
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_Service_Audio_Isochronous_IN(
PTR_USB_DEV_EVENT_STRUCT event
)
{
    uint_8 index;
    uint_8 producer, consumer;
    APP_DATA_STRUCT iso_in_recv;
    USB_ENDPOINTS *usb_ep_data = (USB_ENDPOINTS *)USB_Desc_Get_Endpoints(event->controller_ID);

    iso_in_recv.data_ptr  = event->buffer_ptr;
    iso_in_recv.data_size = event->len;
    /* map the endpoint num to the index of the endpoint structure */
    for(index = 0; index < usb_ep_data->count; index++)
    {
        if(usb_ep_data->ep[index].ep_num ==event->ep_num)
        break;
    }
    producer = g_audio_endpoint_data.ep[index].bin_producer;
    /* if there are no errors de-queue the queue and decrement the no. of
    transfers left, else send the same data again */
    if(event->errors == 0)
    {
        /* de-queue if the send is complete without an error */
        if ((MAX_QUEUE_ELEMS-1) == g_audio_endpoint_data.ep[index].bin_consumer)
        {
            g_audio_endpoint_data.ep[index].bin_consumer = 0;
        }
        else
        {
            g_audio_endpoint_data.ep[index].bin_consumer++;
        }
        g_audio_endpoint_data.ep[index].queue_num--;
    }

    consumer = g_audio_endpoint_data.ep[index].bin_consumer;
    if(0 != g_audio_endpoint_data.ep[index].queue_num)
    {
        /*if bin is not empty */
        USB_CLASS_AUDIO_QUEUE queue;
        /* send the next packet in queue */
        queue = g_audio_endpoint_data.ep[index].queue[consumer];
        (void)USB_Class_Send_Data(queue.controller_ID, queue.channel,
        queue.app_buff, queue.size);
    }

    if(g_audio_class_callback != NULL)
    {
        uint_8 event_type = USB_APP_SEND_COMPLETE;
        if(event->errors != 0)
        {
            event_type = USB_APP_ERROR;
        }
        g_audio_class_callback(event->controller_ID, event_type,
        (uint_8*)(&(event->errors)));
    }
}

/*
** ===================================================================
**     Method      :  USB_Service_Audio_Isochronous_OUT (component USB_AUDIO_CLASS)
**
**     Description :
**         The funtion is callback function of Isochronous Out Endpoint
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_Service_Audio_Isochronous_OUT(
PTR_USB_DEV_EVENT_STRUCT event
)
{
    APP_DATA_STRUCT iso_out_recv;

    if(g_audio_class_callback != NULL)
    {
        if(event->errors != 0)
        {
            g_audio_class_callback(event->controller_ID, USB_APP_ERROR,
            (uint_8*)(&(event->errors)));
        }
        else
        {
            iso_out_recv.data_ptr = event->buffer_ptr;
            iso_out_recv.data_size = event->len;
            g_audio_class_callback(event->controller_ID, USB_APP_DATA_RECEIVED,
            (uint_8*)(&(iso_out_recv)));
        }
    }
}

/*
** ===================================================================
**     Method      :  USB_Class_Audio_Event (component USB_AUDIO_CLASS)
**
**     Description :
**         The funtion initializes Audio endpoint
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_Class_Audio_Event(
uint_8 controller_ID,
uint_8 event,
void* val
)
{
    uint_8 index;

    if(event == USB_APP_ENUM_COMPLETE)
    {
        uint_8 count;
        /* get the endpoints from the descriptor module */
        USB_ENDPOINTS *ep_desc_data = (USB_ENDPOINTS *)
        USB_Desc_Get_Endpoints(controller_ID);

        count = ep_desc_data->count;
        /* deinitialize all endpoints in case they were initialized */
        while(count > 0)
        {
            USB_EP_STRUCT_PTR ep_struct_ptr=
            (USB_EP_STRUCT_PTR) (&ep_desc_data->ep[count - 1]);
            (void)_usb_device_deinit_endpoint(&controller_ID,
            ep_struct_ptr->ep_num, ep_struct_ptr->direction);
            count--;
        }

        /* intialize all non control endpoints */
        while(count < ep_desc_data->count)
        {
            USB_EP_STRUCT_PTR ep_struct=
            (USB_EP_STRUCT_PTR)&ep_desc_data->ep[count];

            (void)_usb_device_init_endpoint(&controller_ID, ep_struct->ep_num,
            ep_struct->size, ep_struct->direction, ep_struct->type, TRUE);

            /* register callback service for the endpoint */
            switch(ep_struct->type)
            {
            case USB_INTERRUPT_PIPE:
                (void)_usb_device_register_service(controller_ID,
                (uint_8)(USB_SERVICE_EP0+ep_struct->ep_num),
                USB_Service_Audio_Status_Interrupt);
                break;
            case USB_ISOCHRONOUS_PIPE:
                if (ep_struct->direction == USB_RECV)
                {
                    (void)_usb_device_register_service(controller_ID,
                    (uint_8)(USB_SERVICE_EP0+ep_struct->ep_num),
                    USB_Service_Audio_Isochronous_OUT);
                }
                else
                {
                    (void)_usb_device_register_service(controller_ID,
                    (uint_8)(USB_SERVICE_EP0+ep_struct->ep_num),
                    USB_Service_Audio_Isochronous_IN);
                }
                break;
            default:
                break;
            }
            /* set the EndPoint Status as Idle in the device layer */
            (void)_usb_device_set_status(&controller_ID,
            (uint_8)(USB_STATUS_ENDPOINT | 1|
            (ep_struct->direction << USB_COMPONENT_DIRECTION_SHIFT)),
            USB_STATUS_IDLE);
            count++;
        }
    }
    else if(event == USB_APP_BUS_RESET)
    {
        /* clear producer and consumer on reset */
        for(index = 0; index < g_audio_endpoint_data.count; index++)
        {
            g_audio_endpoint_data.ep[index].bin_consumer = 0x00;
            g_audio_endpoint_data.ep[index].bin_producer = 0x00;
            g_audio_endpoint_data.ep[index].queue_num    = 0x00;
        }
    }

    if(g_audio_class_callback != NULL)
    {
        /* notify the event to the application */
        g_audio_class_callback(controller_ID, event, val);
    }
}


/*
** ===================================================================
**     Method      :  USB_Set_Cur_Audio_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function sets current attributes of Feature Unit
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Set_Cur_Audio_Feature_Unit(
uint_8 controller_ID,
uint_8 interface,
uint_8 control_selector,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;

    switch(control_selector)
    {
         /*
    case MUTE_CONTROL:
        status = USB_Desc_Set_Cur_Mute(controller_ID,interface,data, size);
        break;     
    case VOLUME_CONTROL:
        status = USB_Desc_Set_Cur_Volume(controller_ID,interface,data,size);
        break;
    case BASS_CONTROL:
        status = USB_Desc_Set_Cur_Bass(controller_ID,interface,data,size);
        break;
    case MID_CONTROL:
        status = USB_Desc_Set_Cur_Mid(controller_ID,interface,data,size);
        break;
    case TREBLE_CONTROL:
        status = USB_Desc_Set_Cur_Treble(controller_ID,interface,data,size);
        break;
    case GRAPHIC_EQUALIZER_CONTROL:
        status=USB_Desc_Set_Cur_Graphic_Equalizer(controller_ID,interface,data,size);
        break;
        */
    
    case AUTOMATIC_GAIN_CONTROL:
        status = USB_Desc_Set_Cur_Automatic_Gain(controller_ID,interface,data,size);
        break;
        
        /*
    case DELAY_CONTROL:
        status = USB_Desc_Set_Cur_Delay(controller_ID,interface,data,size);
        break;
    case BASS_BOOST_CONTROL:
        status = USB_Desc_Set_Cur_Bass_Boost(controller_ID,interface,data,size);
        break;
    case LOUDNESS_CONTROL:
        status = USB_Desc_Set_Cur_Loudness(controller_ID,interface,data,size);
        break;
        */
    default:
        break;
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Set_Min_Audio_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function sets Min attributes of Feature Unit
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
/*
static uint_8 USB_Set_Min_Audio_Feature_Unit(
uint_8 controller_ID,
uint_8 interface,
uint_8 control_selector,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;

    switch(control_selector)
    {
    case VOLUME_CONTROL:
        status = USB_Desc_Set_Min_Volume(controller_ID,interface,data,size);
        break;
    case BASS_CONTROL:
        status = USB_Desc_Set_Min_Bass(controller_ID,interface,data,size);
        break;
    case MID_CONTROL:
        status = USB_Desc_Set_Min_Mid(controller_ID,interface,data,size);
        break;
    case TREBLE_CONTROL:
        status = USB_Desc_Set_Min_Treble(controller_ID,interface,data,size);
        break;
    case GRAPHIC_EQUALIZER_CONTROL:
        status = USB_Desc_Set_Min_Graphic_Equalizer(controller_ID,interface,data,size);
        break;
    case DELAY_CONTROL:
        status = USB_Desc_Set_Min_Delay(controller_ID,interface,data,size);
        break;
    default:
        break;
    }
    return status;
}
*/

/*
** ===================================================================
**     Method      :  USB_Set_Max_Audio_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function sets Max attributes of Feature Unit
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
/*
static uint_8 USB_Set_Max_Audio_Feature_Unit(
uint_8 controller_ID,
uint_8 interface,
uint_8 control_selector,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;

    switch(control_selector)
    {
    case VOLUME_CONTROL:
        status = USB_Desc_Set_Max_Volume(controller_ID,interface,data,size);
        break;
        
    case BASS_CONTROL:
        status = USB_Desc_Set_Max_Bass(controller_ID,interface,data,size);
        break;
    case MID_CONTROL:
        status = USB_Desc_Set_Max_Mid(controller_ID,interface,data,size);
        break;
    case TREBLE_CONTROL:
        status = USB_Desc_Set_Max_Treble(controller_ID,interface,data,size);
        break;
    case GRAPHIC_EQUALIZER_CONTROL:
        status =USB_Desc_Set_Max_Graphic_Equalizer(controller_ID,interface,data,size);
        break;
    case DELAY_CONTROL:
        status = USB_Desc_Set_Max_Delay(controller_ID,interface,data,size);
        break;
    default:
        break;
    }
    return status;
}
*/

/*
** ===================================================================
**     Method      :  USB_Set_Res_Audio_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function sets Resolution attributes of Feature Unit
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
/*
static uint_8 USB_Set_Res_Audio_Feature_Unit(
uint_8 controller_ID,
uint_8 interface,
uint_8 control_selector,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    switch(control_selector)
    {
    case VOLUME_CONTROL:
        status = USB_Desc_Set_Res_Volume(controller_ID,interface,data,size);
        break;
    case BASS_CONTROL:
        status = USB_Desc_Set_Res_Bass(controller_ID,interface,data,size);
        break;
    case MID_CONTROL:
        status = USB_Desc_Set_Res_Mid(controller_ID,interface,data,size);
        break;
    case TREBLE_CONTROL:
        status = USB_Desc_Set_Res_Treble(controller_ID,interface,data,size);
        break;
    case GRAPHIC_EQUALIZER_CONTROL:
        status = USB_Desc_Set_Res_Graphic_Equalizer(controller_ID,interface,data,size);
        break;
    case DELAY_CONTROL:
        status = USB_Desc_Set_Res_Delay(controller_ID,interface,data,size);
        break;
    default:
        break;
    }
    return status;
}
*/

/*
** ===================================================================
**     Method      :  USB_Get_Cur_Audio_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function gets Current attributes of Feature Unit
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Get_Cur_Audio_Feature_Unit(
uint_8 controller_ID,
uint_8 interface,
uint_8 control_selector,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    /* check control selector */
    switch(control_selector)
    {
        /*
    case MUTE_CONTROL:
        status = USB_Desc_Get_Cur_Mute(controller_ID,interface,data,size);
        break;
        
    case VOLUME_CONTROL:
        status = USB_Desc_Get_Cur_Volume(controller_ID,interface,data,size);
        break;
    case BASS_CONTROL:
        status = USB_Desc_Get_Cur_Bass(controller_ID,interface,data,size);
        break;
    case MID_CONTROL:
        status = USB_Desc_Get_Cur_Mid(controller_ID,interface,data,size);
        break;
    case TREBLE_CONTROL:
        status = USB_Desc_Get_Cur_Treble(controller_ID,interface,data,size);
        break;
    case GRAPHIC_EQUALIZER_CONTROL:
        status = USB_Desc_Get_Cur_Graphic_Equalizer(controller_ID,interface,data,size);
        break;
        */
        
    case AUTOMATIC_GAIN_CONTROL:
        status = USB_Desc_Get_Cur_Automatic_Gain(controller_ID,interface,data,size);
        break;
        /*
    case DELAY_CONTROL:
        status = USB_Desc_Get_Cur_Delay(controller_ID,interface,data,size);
        break;
    case BASS_BOOST_CONTROL:
        status = USB_Desc_Get_Cur_Bass_Boost(controller_ID,interface,data,size);
        break;
    case LOUDNESS_CONTROL:
        status = USB_Desc_Get_Cur_Loudness(controller_ID,interface,data,size);
        break;
        */
    default:
        break;
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Get_Min_Audio_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function gets Min attributes of Feature Unit
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
/*
static uint_8 USB_Get_Min_Audio_Feature_Unit(
uint_8 controller_ID,
uint_8 interface,
uint_8 control_selector,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    switch(control_selector)
    {
    case VOLUME_CONTROL:
        status = USB_Desc_Get_Min_Volume(controller_ID,interface,data,size);
        break;
    case BASS_CONTROL:
        status = USB_Desc_Get_Min_Bass(controller_ID,interface,data,size);
        break;
    case MID_CONTROL:
        status = USB_Desc_Get_Min_Mid(controller_ID,interface,data,size);
        break;
    case TREBLE_CONTROL:
        status = USB_Desc_Get_Min_Treble(controller_ID,interface,data,size);
        break;
    case GRAPHIC_EQUALIZER_CONTROL:
        status = USB_Desc_Get_Min_Graphic_Equalizer(controller_ID,interface,data,size);
        break;
    case DELAY_CONTROL:
        status = USB_Desc_Get_Min_Delay(controller_ID,interface,data,size);
        break;
    default:
        break;
    }
    return status;
}
*/

/*
** ===================================================================
**     Method      :  USB_Get_Max_Audio_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function gets Max attributes of Feature Unit
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
/*
static uint_8 USB_Get_Max_Audio_Feature_Unit(
uint_8 controller_ID,
uint_8 interface,
uint_8 control_selector,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    switch(control_selector)
    {
    case VOLUME_CONTROL:
        status = USB_Desc_Get_Max_Volume(controller_ID,interface,data,size);
        break;
    case BASS_CONTROL:
        status = USB_Desc_Get_Max_Bass(controller_ID,interface,data,size);
        break;
    case MID_CONTROL:
        status = USB_Desc_Get_Max_Mid(controller_ID,interface,data,size);
        break;
    case TREBLE_CONTROL:
        status = USB_Desc_Get_Max_Treble(controller_ID,interface,data,size);
        break;
    case GRAPHIC_EQUALIZER_CONTROL:
        status = USB_Desc_Get_Max_Graphic_Equalizer(controller_ID,interface,data,size);
        break;
    case DELAY_CONTROL:
        status = USB_Desc_Get_Max_Delay(controller_ID,interface,data,size);
        break;
    default:
        break;
    }
    return status;
}
*/
/*
** ===================================================================
**     Method      :  USB_Get_Res_Audio_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function gets Resolution attributes of Feature Unit
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
/*
static uint_8 USB_Get_Res_Audio_Feature_Unit(
uint_8 controller_ID,
uint_8 interface,
uint_8 control_selector,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    switch(control_selector)
    {
    case VOLUME_CONTROL:
        status = USB_Desc_Get_Res_Volume(controller_ID,interface,data,size);
        break;
    case BASS_CONTROL:
        status = USB_Desc_Get_Res_Bass(controller_ID,interface,data,size);
        break;
    case MID_CONTROL:
        status = USB_Desc_Get_Res_Mid(controller_ID,interface,data,size);
        break;
    case TREBLE_CONTROL:
        status = USB_Desc_Get_Res_Treble(controller_ID,interface,data,size);
        break;
    case GRAPHIC_EQUALIZER_CONTROL:
        status = USB_Desc_Get_Res_Graphic_Equalizer(controller_ID,interface,data,size);
        break;
    case DELAY_CONTROL:
        status=USB_Desc_Get_Res_Delay(controller_ID,interface,data,size);
        break;
    default:
        break;
    }
    return status;
}
*/
/*
** ===================================================================
**     Method      :  USB_Audio_Set_Control_Terminal (component USB_AUDIO_CLASS)
**
**     Description :
**         The function sets Copy protect level for I/O Terminal
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Audio_Set_Control_Terminal(
uint_8 controller_ID,
USB_SETUP_STRUCT *setup_packet,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;

    switch(setup_packet -> request)
    {
        /*Copy Protect Control only supports the CUR attribute! */
    case SET_CUR:
        if((setup_packet->value >>8) == COPY_PROTECT_CONTROL )
        {
            status = USB_Desc_Set_Copy_Protect(controller_ID,(uint_8)setup_packet->index,data,size);
        }
        break;
    default:
        break;
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Audio_Get_Control_Terminal (component USB_AUDIO_CLASS)
**
**     Description :
**         The function gets Copy protect level for I/O Terminal
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Audio_Get_Control_Terminal(
uint_8 controller_ID,
USB_SETUP_STRUCT *setup_packet,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    switch(setup_packet -> request)
    {
        /* Copy Protect Control only supports the CUR attribute!*/
    case GET_CUR:
        if((setup_packet ->value >>8) == COPY_PROTECT_CONTROL )
        {
            status = USB_Desc_Get_Copy_Protect(controller_ID,(uint_8)setup_packet->index,data,size);
        }
        break;
    default:
        break;
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Audio_Set_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function sets Feature Unit requests
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Audio_Set_Feature_Unit(
uint_8 controller_ID,
USB_SETUP_STRUCT *setup_packet,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 interface, control_selector;
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    /* get current interface */
    interface = (uint_8)setup_packet->index;
    /* get control selector */
    control_selector = (uint_8)(setup_packet->value>>8);

    /* Select SET request Control Feature Unit Module */
    switch(setup_packet->request)
    {
    case SET_CUR:
        /*Set current attributes of Feature Unit*/
        status = USB_Set_Cur_Audio_Feature_Unit(controller_ID,interface,control_selector,data,size);
        break;
        /*
    case SET_MIN:
        status = USB_Set_Min_Audio_Feature_Unit(controller_ID,interface,control_selector,data,size);
        break;
    case SET_MAX:
        status = USB_Set_Max_Audio_Feature_Unit(controller_ID,interface,control_selector,data,size);
        break;
    case SET_RES:
        status = USB_Set_Res_Audio_Feature_Unit(controller_ID,interface,control_selector,data,size);
        break;
        */
    default:
        break;
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Audio_Get_Feature_Unit (component USB_AUDIO_CLASS)
**
**     Description :
**         The function gets Feature Unit requests
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Audio_Get_Feature_Unit(
uint_8 controller_ID,
USB_SETUP_STRUCT *setup_packet,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 interface, control_selector;
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    interface = (uint_8)setup_packet->index;
    control_selector = (uint_8)(setup_packet->value>>8);
    /* Select SET request Control Feature Unit Module */
    switch(setup_packet->request)
    {
    case GET_CUR:
        status = USB_Get_Cur_Audio_Feature_Unit(controller_ID,interface,control_selector,data,size);
        break;
        /*
    case GET_MIN:
        status = USB_Get_Min_Audio_Feature_Unit(controller_ID,interface,control_selector,data,size);
        break;
    case GET_MAX:
        status = USB_Get_Max_Audio_Feature_Unit(controller_ID,interface,control_selector,data,size);
        break;
    case GET_RES:
        status = USB_Get_Res_Audio_Feature_Unit(controller_ID,interface,control_selector,data,size);
        break;
        */
    default:
        break;
    }
    return USB_OK;
}

/*
** ===================================================================
**     Method      :  USB_Set_Request_Interface (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called in response to Set Interface Requests
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Set_Request_Interface(
uint_8 controller_ID,
USB_SETUP_STRUCT *setup_packet,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 i;
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    USB_AUDIO_UNITS *entity_desc_data;
    USB_UT_STRUCT_PTR ut_struct;
    *size = 0;
    /* get the I/O Interface and Feature  from the descriptor module */
    entity_desc_data = (USB_AUDIO_UNITS *)USB_Desc_Get_Entities(controller_ID);
    for(i=0;i<AUDIO_UNIT_COUNT; i++)
    {
        ut_struct=(USB_UT_STRUCT_PTR)&(entity_desc_data->et[i]);
        if((setup_packet->index >>8) == ut_struct->unit_id)
        {
            switch(ut_struct->type)
            {
            case AUDIO_CONTROL_FEATURE_UNIT:
                /* Select SET request Control Feature Unit Module */
                status = USB_Audio_Set_Feature_Unit(controller_ID,setup_packet,data,size);
                break;
            case AUDIO_CONTROL_OUTPUT_TERMINAL:
                /* Select SET request Output Terminal Module */
                status = USB_Audio_Set_Control_Terminal(controller_ID,setup_packet,data,size);
                break;
            default:
                break;
            }
        }
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Get_Request_Interface (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called in response to Get Interface Requests
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Get_Request_Interface(
uint_8 controller_ID,
USB_SETUP_STRUCT *setup_packet,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 i;
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    USB_AUDIO_UNITS *entity_desc_data;
    USB_UT_STRUCT_PTR ut_struct;

    /* get the I/O Interface and Feature  from the descriptor module */
    entity_desc_data = (USB_AUDIO_UNITS *)USB_Desc_Get_Entities(controller_ID);

    for(i=0;i<AUDIO_UNIT_COUNT; i++)
    {
        ut_struct=(USB_UT_STRUCT_PTR)&(entity_desc_data->et[i]);
        if((setup_packet->index >>8) == ut_struct->unit_id)
        {
            switch(ut_struct->type)
            {
            case AUDIO_CONTROL_INPUT_TERMINAL:
                /*Select SET Request Control Input Terminal Module */
                status = USB_Audio_Get_Control_Terminal(controller_ID,setup_packet,data,size);
                break;
            case AUDIO_CONTROL_FEATURE_UNIT:
                /* Select SET request Control Feature Unit Module */
                status = USB_Audio_Get_Feature_Unit(controller_ID,setup_packet,data,size);
                break;
            default:
                break;
            }
        }
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Set_Request_Endpoint (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called in response to Set Endpoint Requests
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Set_Request_Endpoint(
uint_8 controller_ID,
USB_SETUP_STRUCT *setup_packet,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    uint_8 interface;
    uint_8 control_selector;
    uint_16 offset;
    /* get current interface */
    interface = (uint_8)setup_packet->index;
    /* get control selector */
    control_selector = (uint_8)(setup_packet->value>>8);

    switch(setup_packet->request)
    {
    case SET_CUR:
        *size = 0;
        switch(control_selector)
        {
        case SAMPLING_FREQ_CONTROL:
            status = USB_Desc_Set_Cur_Sampling_Frequency(controller_ID,interface,data,size);
            break;
            /*
        case PITCH_CONTROL:
            status = USB_Desc_Set_Cur_Pitch(controller_ID,interface,data,size);
            break;
            */
        default:
            break;
        }
        break;
        /*
    case SET_MIN:
        *size = 0;
        switch(control_selector)
        {
        case SAMPLING_FREQ_CONTROL:
            status = USB_Desc_Set_Min_Sampling_Frequency(controller_ID,interface,data,size);
            break;
        default:
            break;
        }
        break;
    case SET_MAX:
        *size = 0;
        switch(control_selector)
        {
        case SAMPLING_FREQ_CONTROL:
            status = USB_Desc_Set_Max_Sampling_Frequency(controller_ID,interface,data,size);
            break;
        default:
            break;
        }
        break;
    case SET_RES:
        *size = 0;
        switch(control_selector)
        {
        case SAMPLING_FREQ_CONTROL:
            status = USB_Desc_Set_Res_Sampling_Frequency(controller_ID,interface,data,size);
            break;
        default:
            break;
        }
        break;
        */
    case SET_MEM:
        *size = setup_packet->length;
        offset=setup_packet->value;
        status = USB_Desc_Set_Mem_Endpoint(controller_ID,offset,interface,data,size);
        break;
    default:
        break;
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Get_Request_Endpoint (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called in response to Get Endpoint Requests
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Get_Request_Endpoint(
uint_8 controller_ID,
USB_SETUP_STRUCT *setup_packet,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    uint_8 interface;
    uint_8 control_selector;
    uint_16 offset;

    /* get current interface */
    interface = (uint_8)setup_packet->index;
    /* get control selector */
    control_selector = (uint_8)(setup_packet->value >>8);

    switch(setup_packet->request)
    {
    case  GET_CUR:
        switch(control_selector)
        {
        case SAMPLING_FREQ_CONTROL:
            status = USB_Desc_Get_Cur_Sampling_Frequency(controller_ID,interface,data,size);
            break;
            /*
        case PITCH_CONTROL:
            status = USB_Desc_Get_Cur_Pitch(controller_ID,interface,data,size);
            break;
            */
        default:
            break;
        }
        break;
        
        /*
    case GET_MIN:
        switch(control_selector)
        {
        case SAMPLING_FREQ_CONTROL:
            status = USB_Desc_Get_Min_Sampling_Frequency(controller_ID,interface,data,size);
            break;
        default:
            break;
        }
        break;
    case GET_MAX:
        switch(control_selector)
        {
        case SAMPLING_FREQ_CONTROL:
            status = USB_Desc_Get_Max_Sampling_Frequency(controller_ID,interface,data,size);
            break;
        default:
            break;
        }
        break;
    case GET_RES:
        switch(control_selector)
        {
        case SAMPLING_FREQ_CONTROL:
            status = USB_Desc_Get_Res_Sampling_Frequency(controller_ID,interface,data,size);
            break;
        default:
            break;
        }
        break;
        */
    case GET_MEM:
        *size = setup_packet->length;
        offset=setup_packet->value;
        status = USB_Desc_Get_Mem_Endpoint(controller_ID,offset,interface,data,size);
        break;
    default:
        break;
    }
    return status;
}

/*
** ===================================================================
**     Method      :  USB_Other_Requests (component USB_AUDIO_CLASS)
**
**     Description :
**         The funtion provides flexibilty to add class and vendor 
**         specific requests
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint_8 USB_Other_Requests(
uint_8 controller_ID,
USB_SETUP_STRUCT *setup_packet,
uint_8_ptr *data,
USB_PACKET_SIZE *size
)
{
    uint_8 status = USBERR_INVALID_REQ_TYPE;
    /* point to the data which comes after the setup packet */
    *data = ((uint_8*)setup_packet)+USB_SETUP_PKT_SIZE;
    if (size == NULL)
    {
        return USBERR_GET_MEMORY_FAILED;
    }
    switch(setup_packet->request_type)
    {
        /* Set I/O Terminal and Feature Unit */
    case SET_REQUEST_ITF:
        status = USB_Set_Request_Interface(controller_ID,setup_packet,data,size);
        break;
        /*Get I/O Terminal and Feature Unit */
    case GET_REQUEST_ITF:
        status = USB_Get_Request_Interface(controller_ID,setup_packet,data,size);
        break;
        /* Set Endpoint Request */
    case SET_REQUEST_EP:
        status = USB_Set_Request_Endpoint(controller_ID,setup_packet,data,size);
        break;
        /* Get Endpoint Request */
    case GET_REQUEST_EP:
        status = USB_Get_Request_Endpoint(controller_ID,setup_packet,data,size);
        break;
    default:
        break;
    } /* end of switch */
    return status;
}

/*
** ===================================================================
**     Method      :  usb_audio_USB_Class_Audio_Init (component USB_AUDIO_CLASS)
**     Description :
**         The funtion initializes the Device and Controller layer
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         audio_class_callback - 
**         vendor_req_callback - 
**         param_callback  - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Class_Audio_Init(
uint_8 controller_ID,
USB_CLASS_CALLBACK audio_class_callback,
USB_REQ_FUNC vendor_req_callback,
USB_CLASS_CALLBACK param_callback
)
{
    uint_8 index;
    USB_ENDPOINTS *ep_desc_data = (USB_ENDPOINTS *)
    USB_Desc_Get_Endpoints(controller_ID);

    /* Initialize the device layer*/
    uint_8 status = _usb_device_init(controller_ID, NULL,
    (uint_8)(ep_desc_data->count+1));
    if(status == USB_OK)
    {
        /* Initialize the generic class functions */
        status = USB_Class_Init(controller_ID,USB_Class_Audio_Event,
        USB_Other_Requests);
        if(status == USB_OK)
        {
            g_audio_endpoint_data.count = ep_desc_data->count;
            for(index = 0; index < ep_desc_data->count; index++)
            {
                g_audio_endpoint_data.ep[index].endpoint =
                ep_desc_data->ep[index].ep_num;
                g_audio_endpoint_data.ep[index].type =
                ep_desc_data->ep[index].type;
                g_audio_endpoint_data.ep[index].bin_consumer = 0x00;
                g_audio_endpoint_data.ep[index].bin_producer = 0x00;
                g_audio_endpoint_data.ep[index].queue_num    = 0x00;
            }

            /* save the Audio class callback pointer */
            g_audio_class_callback = audio_class_callback;

            /* save the vendor request callback pointer */
            g_vendor_req_callback = vendor_req_callback;

            /* Save the callback to ask application for class specific params*/
            g_param_callback = param_callback;
        }
    }
    return status;
}

/*
** ===================================================================
**     Method      :  usb_audio_USB_Class_Audio_DeInit (component USB_AUDIO_CLASS)
**     Description :
**         The funtion de-initializes the Device and Controller layer
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Class_Audio_DeInit(
uint_8 controller_ID
)
{
    uint_8 status;

    /* free the Audio class callback pointer */
    g_audio_class_callback = NULL;

    /* free the vendor request callback pointer */
    g_vendor_req_callback = NULL;

    /* free the callback to ask application for class specific params*/
    g_param_callback = NULL;

    /* Call common class deinit function */
    status = USB_Class_DeInit(controller_ID);

    if(status == USB_OK)
    /* Call device deinit function */
    status = _usb_device_deinit();

    return status;
}

/*
** ===================================================================
**     Method      :  usb_audio_USB_Class_Audio_Send_Data (component USB_AUDIO_CLASS)
**     Description :
**         This fucntion is used by Application to send data through
**         Audio class
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         ep_num          - 
**         app_buff        - 
**         size            - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Class_Audio_Send_Data(
uint_8 controller_ID,
uint_8 ep_num,
uint_8_ptr app_buff,
USB_PACKET_SIZE size
)
{
    uint_8 status = USB_OK;
    PTR_USB_CLASS_AUDIO_QUEUE queue_tmp;
    uint_8 index;
    uint_8 producer, queue_num;

    USB_ENDPOINTS *usb_ep_data = (USB_ENDPOINTS *)
    USB_Desc_Get_Endpoints(controller_ID);

    /* map the endpoint num to the index of the endpoint structure */

    for(index = 0; index < usb_ep_data->count; index++)
    {
        if(usb_ep_data->ep[index].ep_num == ep_num)
        break;
    }

    producer = g_audio_endpoint_data.ep[index].bin_producer;
    queue_num = g_audio_endpoint_data.ep[index].queue_num;

    if(MAX_QUEUE_ELEMS != queue_num)
    {
        /* the bin is not full*/
        /* put all send request parameters in the endpoint data structure */
        queue_tmp = &(g_audio_endpoint_data.ep[index].queue[producer]);
        queue_tmp->controller_ID  = controller_ID;
        queue_tmp->channel        = ep_num;
        queue_tmp->app_buff       = app_buff;
        queue_tmp->size           = size;

        /* increment producer bin by 1*/
        if (producer == (MAX_QUEUE_ELEMS - 1))
        {
            g_audio_endpoint_data.ep[index].bin_producer = 0;
        }
        else
        {
            g_audio_endpoint_data.ep[index].bin_producer++;
        }
        g_audio_endpoint_data.ep[index].queue_num++;

        if(g_audio_endpoint_data.ep[index].queue_num == 1)
        {
            status = USB_Class_Send_Data(controller_ID, ep_num, app_buff,size);
        }
    }
    else /* bin is full */
    {
        status = USBERR_DEVICE_BUSY;
    }
    return status;
}

/*
** ===================================================================
**     Method      :  usb_audio_USB_Class_Audio_Recv_Data (component USB_AUDIO_CLASS)
**     Description :
**         This function receives Data from Host.
**     Parameters  :
**         NAME            - DESCRIPTION
**         controller_ID   - 
**         ep_num          - 
**         app_buff        - 
**         size            - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint_8 USB_Class_Audio_Recv_Data(
uint_8 controller_ID,
uint_8 ep_num,
uint_8_ptr app_buff,
USB_PACKET_SIZE size
)
{
    uint_8 status;
    status = _usb_device_recv_data(&controller_ID,ep_num,app_buff,size);
    return status;
}

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.08]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
/* EOF */


