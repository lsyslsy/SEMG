Debug info from  (Device - PE_Types)  (Module - PE_Types)


{{DEVELOPMENT}} --------(((DEBUGINFO)))--------{{DEVELOPMENT}} 

 DRIVER SYMBOLS (alphabet order)
-------------------------------
Abstract=Common\PE_TypesAbstract.inc
Doc_Misra_Rule_1=1.1
Doc_Misra_Rule_10=8.10
Doc_Misra_Rule_10_Description=All declarations and definitions of objects or function at file scope shall have internal linkage unless external linkage is required.
Doc_Misra_Rule_10_Lint=Info 765: external 'function' could be made static [MISRA 2004 Rule 8.10]
Doc_Misra_Rule_10_Reason=Device Initialization - ISR declaration is subject of various modifications by the user and may or may not be copied to another module - static is not used.
Doc_Misra_Rule_10_Type=Required
Doc_Misra_Rule_11=10.1
Doc_Misra_Rule_11_Description=The value of an expression of integer type shall not be implicitly converted to a different underlying type.
Doc_Misra_Rule_11_Lint=Note 960: Violates MISRA 2004 Required Rule 10.1, Implicit conversion of integer to smaller type
Doc_Misra_Rule_11_Reason=
Doc_Misra_Rule_11_Type=Required
Doc_Misra_Rule_12=11.3
Doc_Misra_Rule_12_Description=A cast should not be performed between a pointer type and an integral type.
Doc_Misra_Rule_12_Lint=Note 923: cast from 'integer type' to pointer [Encompasses MISRA 2004 Rules 11.1 and 11.3], [MISRA 2004 Rule 11.3]
Doc_Misra_Rule_12_Reason=IO map is based on structures and typecasting from a peripheral base address (integer constant) to a pointer type is used to get a pointer to the given peripheral structure used to access a peripheral registers.
Doc_Misra_Rule_12_Type=Advisory
Doc_Misra_Rule_13=11.4
Doc_Misra_Rule_13_Description=A cast should be not be performed between a pointer to object type and different pointer to object type
Doc_Misra_Rule_13_Lint=Note 929: cast from pointer to pointer [MISRA 2004 Rule 11.4]
Doc_Misra_Rule_13_Reason=See detailed description for particular component
Doc_Misra_Rule_13_Type=Advisory
Doc_Misra_Rule_14=12.1
Doc_Misra_Rule_14_Description=Limited dependence should be placed on C's operator precedence rules in expressions.
Doc_Misra_Rule_14_Lint=Note 961: Violates MISRA 2004 Advisory Rule 12.1, dependence placed on C's operator precedence; operators: ',' and ','
Doc_Misra_Rule_14_Reason=
Doc_Misra_Rule_14_Type=Advisory
Doc_Misra_Rule_15=12.8
Doc_Misra_Rule_15_Description=The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand.
Doc_Misra_Rule_15_Lint=Warning 572: Excessive shift value (precision 2 shifted right by 8) [MISRA 2004 Rule 12.8]
Doc_Misra_Rule_15_Reason=
Doc_Misra_Rule_15_Type=Required
Doc_Misra_Rule_16=12.10
Doc_Misra_Rule_16_Description=The comma operator shall not be used.
Doc_Misra_Rule_16_Lint=Note 960: Violates MISRA 2004 Required Rule 12.10, comma operator used
Doc_Misra_Rule_16_Reason=Comma operator is used in PDD macros.
Doc_Misra_Rule_16_Type=Required
Doc_Misra_Rule_17=12.11
Doc_Misra_Rule_17_Description=Evaluation of constant unsigned integer expressions should not lead to wrap-around.
Doc_Misra_Rule_17_Lint=Warning 648: Overflow in computing constant for operation: 'unsigned shift left' [MISRA 2004 Rule 12.11]
Doc_Misra_Rule_17_Reason=
Doc_Misra_Rule_17_Type=Advisory
Doc_Misra_Rule_18=13.7
Doc_Misra_Rule_18_Description=Boolean operations whose results are invariant shall not be permitted.
Doc_Misra_Rule_18_Lint=Warning 506: Constant value Boolean [MISRA 2004 Rules 13.7 and 14.1]
Doc_Misra_Rule_18_Reason=PDD macros define constants that can be passed as parameters to these macros.
Doc_Misra_Rule_18_Type=Required
Doc_Misra_Rule_19=14.2
Doc_Misra_Rule_19_Description=All non-null statements shall either: <br/>a) have at least one side effect however executed, <br/>or b) cause control flow to change.
Doc_Misra_Rule_19_Lint=Warning 522: Highest operation, operator ',', lacks side-effects
Doc_Misra_Rule_19_Reason=Some PDD macros have two commas in the macro implementation.
Doc_Misra_Rule_19_Type=Required
Doc_Misra_Rule_1_Description=All code shall conform to ISO 9899-1990 (C-code guideline)
Doc_Misra_Rule_1_Lint=Note 950: Non-ANSI reserved word or construct [MISRA 2004 Rules 1.1 and 2.2]
Doc_Misra_Rule_1_Reason=Non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt, CONVERT_TO_PAGED (RS08 only).
Doc_Misra_Rule_1_Type=Required
Doc_Misra_Rule_2=1.4
Doc_Misra_Rule_20=14.7
Doc_Misra_Rule_20_Description=A function shall have a single point of exit at the end of the function.
Doc_Misra_Rule_20_Lint=Note 904: Return statement before end of function [MISRA 2004 Rule 14.7]
Doc_Misra_Rule_20_Reason=Use of multiple return statements simplifies the code logic.
Doc_Misra_Rule_20_Type=Required
Doc_Misra_Rule_21=18.4
Doc_Misra_Rule_21_Description=Unions shall not be used.
Doc_Misra_Rule_21_Lint=Note 960: Violates MISRA 2004 Required Rule 18.4, unions shall not be used
Doc_Misra_Rule_21_Reason=Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.
Doc_Misra_Rule_21_Type=Required
Doc_Misra_Rule_22=19.13
Doc_Misra_Rule_22_Description=The # and ## preprocessor operators should not be used.
Doc_Misra_Rule_22_Lint=Note 961: Violates MISRA 2004 Advisory Rule 19.13, '#/##' operator used
Doc_Misra_Rule_22_Reason=Preprocessor operators are used to convert bit name to bit mask in macros for accessing peripheral registers.
Doc_Misra_Rule_22_Type=Advisory
Doc_Misra_Rule_2_Description=The compiler/linker shall be checked to ensure that 31 character significance and case sensitivity are supported for external identifiers.
Doc_Misra_Rule_2_Lint=Note Warning 621: Identifier clash [MISRA 2004 Rules 1.2, 1.4 and 5.1]
Doc_Misra_Rule_2_Reason=IO map defines register access constants. The constants' names contain peripheral name, register name, bit name and suffix _MASK/_SHIFT.
Doc_Misra_Rule_2_Type=Required
Doc_Misra_Rule_3=2.1
Doc_Misra_Rule_3_Description=Assembly language shall be encapsulated and isolated.
Doc_Misra_Rule_3_Lint=Note 950: Non-ANSI reserved word or construct [MISRA 2004 Rules 1.1 and 2.2]
Doc_Misra_Rule_3_Reason=Non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt, CONVERT_TO_PAGED (RS08 only).
Doc_Misra_Rule_3_Type=Required
Doc_Misra_Rule_4=3.1
Doc_Misra_Rule_4_Description=All usage of implementation-defined behavior shall be documented.
Doc_Misra_Rule_4_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_4_Reason=Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:
Doc_Misra_Rule_4_Type=Required
Doc_Misra_Rule_5=3.2
Doc_Misra_Rule_5_Description=The character set and the corresponding encoding shall be documented.
Doc_Misra_Rule_5_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_5_Reason=Basic character set (see ISO 9899) is used in execution character set. Execution character set uses ASCII encoding (possible codes 0-255). Exception to basic character set: Term component uses NULL(0x00), CR (0x0D), LF(0x0A).
Doc_Misra_Rule_5_Type=Required
Doc_Misra_Rule_6=3.3
Doc_Misra_Rule_6_Description=The implementation of integer division in the chosen compiler should be determined, documented and taken into account.
Doc_Misra_Rule_6_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_6_Reason=The way a Compiler implements division and modulo for negative operands is determined by the hardware implementation of the target's division instructions. See documentation of CodeWarrior S12(X) Build tools for more information.
Doc_Misra_Rule_6_Type=Advisory
Doc_Misra_Rule_7=3.4
Doc_Misra_Rule_7_Description=All uses of the #pragma directives shall be documented and explained.
Doc_Misra_Rule_7_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_7_Reason=Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.
Doc_Misra_Rule_7_Type=Required
Doc_Misra_Rule_8=3.6
Doc_Misra_Rule_8_Description=All libraries used in production code shall be written to comply with the provision of this document and shall have been subject to appropriate validation.
Doc_Misra_Rule_8_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_8_Reason=Only libraries included in CodeWarrior development studio are used in the generated source code.
Doc_Misra_Rule_8_Type=Required
Doc_Misra_Rule_9=6.3
Doc_Misra_Rule_9_Description=Typedef that indicates size and signedness should be used in place of basic types.
Doc_Misra_Rule_9_Lint=Info 970: Use of modifier or type 'int' outside of a typedef [MISRA Rule 6.3]
Doc_Misra_Rule_9_Reason=The type of the function is defined by tool set. ProcessorExpert definition must comply..
Doc_Misra_Rule_9_Type=Advisory
DriverAuthor=Marek Vinkler
DriverDate=29.08.2006
DriverVersion=01.01
EndOfInterface=
Location_x=PE_Types.h
Settings=Common\PE_TypesSettings.inc
Doc_Misra_Rule_10_Location=[Cpu|Vectors.c|Cpu|Vectors.c|Cpu|Vectors.c|Cpu|Vectors.c|Cpu|Vectors.c|Cpu|Vectors.c|Cpu|Vectors.c]
Doc_Misra_Rule_11_Location=[PE_Types.h|SDHC_LDD|PE_Types.h|SDHC_LDD|PE_Types.h|SDHC_LDD|PE_Types.h|SDHC_LDD|PE_Types.h|SDHC_LDD|PE_Types.h|SDHC_LDD|PE_Types.h|SDHC_LDD]
Doc_Misra_Rule_11_Location_Reason=[Call of the library function __set_FAULTMASK(). The code violates this rule for IAR compiler only.|Cannot shift by a value resulting from a complex expression.|Call of the library function __set_FAULTMASK(). The code violates this rule for IAR compiler only.|Cannot shift by a value resulting from a complex expression.|Call of the library function __set_FAULTMASK(). The code violates this rule for IAR compiler only.|Cannot shift by a value resulting from a complex expression.|Call of the library function __set_FAULTMASK(). The code violates this rule for IAR compiler only.|Cannot shift by a value resulting from a complex expression.|Call of the library function __set_FAULTMASK(). The code violates this rule for IAR compiler only.|Cannot shift by a value resulting from a complex expression.|Call of the library function __set_FAULTMASK(). The code violates this rule for IAR compiler only.|Cannot shift by a value resulting from a complex expression.|Call of the library function __set_FAULTMASK(). The code violates this rule for IAR compiler only.|Cannot shift by a value resulting from a complex expression.]
Doc_Misra_Rule_12_Location=[IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h]
Doc_Misra_Rule_13_Location=[Vectors.c|Serial_LDD|SPIMaster_LDD|SPISlave_LDD|SSI_LDD|USB_LDD|Vectors.c|Serial_LDD|SPIMaster_LDD|SPISlave_LDD|SSI_LDD|USB_LDD|Vectors.c|Serial_LDD|SPIMaster_LDD|SPISlave_LDD|SSI_LDD|USB_LDD|Vectors.c|Serial_LDD|SPIMaster_LDD|SPISlave_LDD|SSI_LDD|USB_LDD|Vectors.c|Serial_LDD|SPIMaster_LDD|SPISlave_LDD|SSI_LDD|USB_LDD|Vectors.c|Serial_LDD|SPIMaster_LDD|SPISlave_LDD|SSI_LDD|USB_LDD|Vectors.c|Serial_LDD|SPIMaster_LDD|SPISlave_LDD|SSI_LDD|USB_LDD]
Doc_Misra_Rule_13_Location_Reason=[Need to explicitly cast pointers to the general ISR for Interrupt vector table|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointers is used in StartTransaction, HostQueueTransfer and Init methods.|Need to explicitly cast pointers to the general ISR for Interrupt vector table|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointers is used in StartTransaction, HostQueueTransfer and Init methods.|Need to explicitly cast pointers to the general ISR for Interrupt vector table|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointers is used in StartTransaction, HostQueueTransfer and Init methods.|Need to explicitly cast pointers to the general ISR for Interrupt vector table|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointers is used in StartTransaction, HostQueueTransfer and Init methods.|Need to explicitly cast pointers to the general ISR for Interrupt vector table|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointers is used in StartTransaction, HostQueueTransfer and Init methods.|Need to explicitly cast pointers to the general ISR for Interrupt vector table|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointers is used in StartTransaction, HostQueueTransfer and Init methods.|Need to explicitly cast pointers to the general ISR for Interrupt vector table|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointers is used in StartTransaction, HostQueueTransfer and Init methods.]
Doc_Misra_Rule_14_Location=[SDHC_LDD|Ethernet_LDD|SDHC_LDD|Ethernet_LDD|SDHC_LDD|Ethernet_LDD|SDHC_LDD|Ethernet_LDD|SDHC_LDD|Ethernet_LDD|SDHC_LDD|Ethernet_LDD|SDHC_LDD|Ethernet_LDD]
Doc_Misra_Rule_14_Location_Reason=[Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.]
Doc_Misra_Rule_15_Location=[Ethernet_LDD|TimerUnit_LDD|Serial_LDD|Ethernet_LDD|TimerUnit_LDD|Serial_LDD|Ethernet_LDD|TimerUnit_LDD|Serial_LDD|Ethernet_LDD|TimerUnit_LDD|Serial_LDD|Ethernet_LDD|TimerUnit_LDD|Serial_LDD|Ethernet_LDD|TimerUnit_LDD|Serial_LDD|Ethernet_LDD|TimerUnit_LDD|Serial_LDD]
Doc_Misra_Rule_15_Location_Reason=[Macro for endianness conversion cannot be used on constants.|One of predefined constants for macro LPTMR_PDD_SetDivider has value 1.|PDD macros use shift operations that can cause MISRA violations when a constant with value less than 256 is passed as an argument.|Macro for endianness conversion cannot be used on constants.|One of predefined constants for macro LPTMR_PDD_SetDivider has value 1.|PDD macros use shift operations that can cause MISRA violations when a constant with value less than 256 is passed as an argument.|Macro for endianness conversion cannot be used on constants.|One of predefined constants for macro LPTMR_PDD_SetDivider has value 1.|PDD macros use shift operations that can cause MISRA violations when a constant with value less than 256 is passed as an argument.|Macro for endianness conversion cannot be used on constants.|One of predefined constants for macro LPTMR_PDD_SetDivider has value 1.|PDD macros use shift operations that can cause MISRA violations when a constant with value less than 256 is passed as an argument.|Macro for endianness conversion cannot be used on constants.|One of predefined constants for macro LPTMR_PDD_SetDivider has value 1.|PDD macros use shift operations that can cause MISRA violations when a constant with value less than 256 is passed as an argument.|Macro for endianness conversion cannot be used on constants.|One of predefined constants for macro LPTMR_PDD_SetDivider has value 1.|PDD macros use shift operations that can cause MISRA violations when a constant with value less than 256 is passed as an argument.|Macro for endianness conversion cannot be used on constants.|One of predefined constants for macro LPTMR_PDD_SetDivider has value 1.|PDD macros use shift operations that can cause MISRA violations when a constant with value less than 256 is passed as an argument.]
Doc_Misra_Rule_16_Location=[Global|Global|Global|Global|Global|Global|Global]
Doc_Misra_Rule_17_Location=[Ethernet_LDD|Ethernet_LDD|Ethernet_LDD|Ethernet_LDD|Ethernet_LDD|Ethernet_LDD|Ethernet_LDD]
Doc_Misra_Rule_17_Location_Reason=[Macro for endianness conversion cannot be used on constants.|Macro for endianness conversion cannot be used on constants.|Macro for endianness conversion cannot be used on constants.|Macro for endianness conversion cannot be used on constants.|Macro for endianness conversion cannot be used on constants.|Macro for endianness conversion cannot be used on constants.|Macro for endianness conversion cannot be used on constants.]
Doc_Misra_Rule_18_Location=[Global|Global|Global|Global|Global|Global|Global]
Doc_Misra_Rule_19_Location=[Global|Global|Global|Global|Global|Global|Global]
Doc_Misra_Rule_1_Location=[PE_Types.h|Cpu|Vectors.c|FLASH_LDD|PE_Types.h|Cpu|Vectors.c|FLASH_LDD|PE_Types.h|Cpu|Vectors.c|FLASH_LDD|PE_Types.h|Cpu|Vectors.c|FLASH_LDD|PE_Types.h|Cpu|Vectors.c|FLASH_LDD|PE_Types.h|Cpu|Vectors.c|FLASH_LDD|PE_Types.h|Cpu|Vectors.c|FLASH_LDD]
Doc_Misra_Rule_1_Location_Reason=[The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.]
Doc_Misra_Rule_20_Location=[Global|Global|Global|Global|Global|Global|Global]
Doc_Misra_Rule_21_Location=[Global|IO_Map.h|Global|IO_Map.h|Global|IO_Map.h|Global|IO_Map.h|Global|IO_Map.h|Global|IO_Map.h|Global|IO_Map.h]
Doc_Misra_Rule_21_Location_Reason=[Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.]
Doc_Misra_Rule_22_Location=[PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h]
Doc_Misra_Rule_22_Location_Reason=[Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.]
Doc_Misra_Rule_2_Location=[IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h]
Doc_Misra_Rule_3_Location=[PE_Types.h|Cpu|Vectors.c|PE_Types.h|Cpu|Vectors.c|PE_Types.h|Cpu|Vectors.c|PE_Types.h|Cpu|Vectors.c|PE_Types.h|Cpu|Vectors.c|PE_Types.h|Cpu|Vectors.c|PE_Types.h|Cpu|Vectors.c]
Doc_Misra_Rule_3_Location_Reason=[The file contains ASM language, but it is isolated in C macros.|The file contains ASM language, but it is isolated in C macros.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The file contains ASM language, but it is isolated in C macros.|The file contains ASM language, but it is isolated in C macros.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The file contains ASM language, but it is isolated in C macros.|The file contains ASM language, but it is isolated in C macros.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The file contains ASM language, but it is isolated in C macros.|The file contains ASM language, but it is isolated in C macros.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The file contains ASM language, but it is isolated in C macros.|The file contains ASM language, but it is isolated in C macros.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The file contains ASM language, but it is isolated in C macros.|The file contains ASM language, but it is isolated in C macros.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The file contains ASM language, but it is isolated in C macros.|The file contains ASM language, but it is isolated in C macros.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.]
Doc_Misra_Rule_4_Location=[PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info]
Doc_Misra_Rule_4_Location_Reason=[Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:|Program overloads void __init_hardware(void) function from the standard startup to provide initialization of clocks and external bus early after reset, see <a href="ResetScenario.html">Reset Scenario</a>.|Program is finished at the end of main function in the infinite loop.|Execution character set and corresponding values are documented in rule 3.2 in this table.|Volatile declarations are used to access peripheral registers (memory mapped).|Pragma directives are used and commented in the source code. See also documented rule 3.4 in this table.|Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:|Program overloads void __init_hardware(void) function from the standard startup to provide initialization of clocks and external bus early after reset, see <a href="ResetScenario.html">Reset Scenario</a>.|Program is finished at the end of main function in the infinite loop.|Execution character set and corresponding values are documented in rule 3.2 in this table.|Volatile declarations are used to access peripheral registers (memory mapped).|Pragma directives are used and commented in the source code. See also documented rule 3.4 in this table.|Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:|Program overloads void __init_hardware(void) function from the standard startup to provide initialization of clocks and external bus early after reset, see <a href="ResetScenario.html">Reset Scenario</a>.|Program is finished at the end of main function in the infinite loop.|Execution character set and corresponding values are documented in rule 3.2 in this table.|Volatile declarations are used to access peripheral registers (memory mapped).|Pragma directives are used and commented in the source code. See also documented rule 3.4 in this table.|Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:|Program overloads void __init_hardware(void) function from the standard startup to provide initialization of clocks and external bus early after reset, see <a href="ResetScenario.html">Reset Scenario</a>.|Program is finished at the end of main function in the infinite loop.|Execution character set and corresponding values are documented in rule 3.2 in this table.|Volatile declarations are used to access peripheral registers (memory mapped).|Pragma directives are used and commented in the source code. See also documented rule 3.4 in this table.|Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:|Program overloads void __init_hardware(void) function from the standard startup to provide initialization of clocks and external bus early after reset, see <a href="ResetScenario.html">Reset Scenario</a>.|Program is finished at the end of main function in the infinite loop.|Execution character set and corresponding values are documented in rule 3.2 in this table.|Volatile declarations are used to access peripheral registers (memory mapped).|Pragma directives are used and commented in the source code. See also documented rule 3.4 in this table.|Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:|Program overloads void __init_hardware(void) function from the standard startup to provide initialization of clocks and external bus early after reset, see <a href="ResetScenario.html">Reset Scenario</a>.|Program is finished at the end of main function in the infinite loop.|Execution character set and corresponding values are documented in rule 3.2 in this table.|Volatile declarations are used to access peripheral registers (memory mapped).|Pragma directives are used and commented in the source code. See also documented rule 3.4 in this table.|Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:|Program overloads void __init_hardware(void) function from the standard startup to provide initialization of clocks and external bus early after reset, see <a href="ResetScenario.html">Reset Scenario</a>.|Program is finished at the end of main function in the infinite loop.|Execution character set and corresponding values are documented in rule 3.2 in this table.|Volatile declarations are used to access peripheral registers (memory mapped).|Pragma directives are used and commented in the source code. See also documented rule 3.4 in this table.]
Doc_Misra_Rule_5_Location=[PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info]
Doc_Misra_Rule_6_Location=[PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info]
Doc_Misra_Rule_7_Location=[PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info]
Doc_Misra_Rule_7_Location_Reason=[Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.|Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.|Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.|Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.|Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.|Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.|Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.]
Doc_Misra_Rule_8_Location=[CAU_LDD|CAU_LDD|CAU_LDD|CAU_LDD|CAU_LDD|CAU_LDD|CAU_LDD]
Doc_Misra_Rule_8_Location_Reason=[CAU component uses an external CAU library that is not MISRA compliant. CAU component's code itself is MISRA compliant.|CAU component uses an external CAU library that is not MISRA compliant. CAU component's code itself is MISRA compliant.|CAU component uses an external CAU library that is not MISRA compliant. CAU component's code itself is MISRA compliant.|CAU component uses an external CAU library that is not MISRA compliant. CAU component's code itself is MISRA compliant.|CAU component uses an external CAU library that is not MISRA compliant. CAU component's code itself is MISRA compliant.|CAU component uses an external CAU library that is not MISRA compliant. CAU component's code itself is MISRA compliant.|CAU component uses an external CAU library that is not MISRA compliant. CAU component's code itself is MISRA compliant.]
Doc_Misra_Rule_9_Location=[CPU|Main.c|CPU|Main.c|CPU|Main.c|CPU|Main.c|CPU|Main.c|CPU|Main.c|CPU|Main.c]
PE_MisraErrorCodes=[950]
revAuth=[LH|]
revCmnt_0=[Type char_t definition added.|Support of C++.]
revDate=[17.09.2012|14.01.2009]
revLvl=[3|0]
revVer=[01.01|01.00]
revVrf=[PE|]

 LOCAL SYMBOLS (alphabet order)
-------------------------------
DeviceModule=PE_Types
DeviceName=PE_Types
DeviceType=PE_Types
EventModules=[Events]
ModuleName=PE_Types

GLOBAL SYMBOLS (alphabet order)
-------------------------------
ADC0AsynchroClockAddr=1073983496
ADC0AsynchroClockReg=ADC0_CFG1
ADC0BusClockAddr=1073983496
ADC0BusClockReg=ADC0_CFG1
ADC0ClkSelAddr=1073983496
ADC0ClkSelReg=ADC0_CFG1
ActiveConfigIdentifier=PEcfg_FLASH
ActiveConfiguration=FLASH
CPUDB_BUS_FREQ_HZ_MAX=24000000
CPUDB_CPU_MASTER=MKL25Z4
CPUDB_CW_MCU_ID=28695
CPUDB_CW_MCU_NAME=MKL25Z128xxx4
CPUDB_LQFP80=-1
CPUDB_MKL25Z128xxx4=-1
CPUDB_MKL25Z4=-1
CPUDB_PACKAGE=LQFP80
CPUDB_PLL_INPUT_FREQ_HZ_MAX=4000000
CPUDB_PLL_INPUT_FREQ_HZ_MIN=2000000
CPUDB_PLL_OUTPUT_FREQ_HZ_MAX=100000000
CPUDB_PLL_OUTPUT_FREQ_HZ_MIN=48000000
CPUDB_ProgramFlashBlockCount=1
CPUDB_ProgramFlashEraseUnitSize=1024
CPUDB_ProgramFlashSize=131072
CPUDB_ProgramFlashWriteUnitSize=4
CPUDB_SYSTEM_FREQ_HZ_MAX=48000000
CPU_DB_version=3.00.000
CPUendian=little
CPUfamily=Kinetis
CPUproducer=Freescale
CPUrunSpeedModeNum=1
CPUsubFamily=MKL25
CPUtype=MKL25Z128LK4
CPUvariant=MKL25Z128VLK4
ClientDir_Binary=E:\USB_proccessor_expert_update\Test\20121119_Processor_expert\AUDIO_CLASS\DEVICE\USB_AUDIO_DEVICE_MKL25Z128_PEx\Sources\
ClientDir_Code=E:\USB_proccessor_expert_update\Test\20121119_Processor_expert\AUDIO_CLASS\DEVICE\USB_AUDIO_DEVICE_MKL25Z128_PEx\Generated_Code\
ClientDir_PE=D:\FreeScale\CW MCU v10.3_B121029\MCU\ProcessorExpert\
ClientDir_Project=E:\USB_proccessor_expert_update\Test\20121119_Processor_expert\AUDIO_CLASS\DEVICE\USB_AUDIO_DEVICE_MKL25Z128_PEx\
CommentBrackets=/**/
Compiler=GNUC
CompilerID=GNU C Compiler
DirRel_Binary=Sources\
DirRel_BinaryToEvents=
DirRel_Code=Generated_Code\
DirRel_Docs=Documentation\
DirRel_EventToBinary=
DirRel_Events=Sources\
DirRel_ProjectSettings=Project_Settings\
EclipseProjectName=USB_AUDIO_DEVICE_MKL25Z128_PEx
InterruptTableType=ROM
Language=ANSIC
Not_for_MPC512x=
OnChipEEPROM=0
OnChipFLASH=131072
OnChipRAM=16384
PE_DEBUG=
PE_DEVELOPMENT=
PE_ECLIPSE=
PE_GENERATING=
PE_G_CPUCFG_AutoIncludeIO_Map=yes
PE_G_CPUCFG_EntryPointFunctionName=__init_hardware
PE_G_CPUCFG_EntryPointFunctionReturn=
PE_G_CPUCFG_EntryPointFunctionReturnType=void __attribute__ ((constructor))
PE_G_CPUCFG_GenerateLinkerFile=yes
PE_G_CPUCFG_GenerateMainModule=yes
PE_G_CPUCFG_InitIntVectorTableSym=yes
PE_G_CPUCFG_ManageInterruptVectorTable=yes
PE_G_GenBitMask=
PE_G_InternalMethodDescriptionNotFound=
PE_G_MisraCnfBackParams_0=
PE_G_MisraCnfParams_0=
PE_G_MisraRuleList_0=
PE_G_MisraStackIdx=-1
PE_G_NO_SETREGMACROS=
PE_G_RTOSAdap_regCompIndex=0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDevice1msTimer=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceError=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceReset=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceResume=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceSetupPacket=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceSof=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceSpeedDetect=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceSuspend=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDevice1msTimer=(void (*)(LDD_TUserData *UserDataPtr))&USB_LDD_USB_LDD_OnDevice1msTimer
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceError=(void (*)(LDD_TUserData *UserDataPtr, uint8_t ErrorSource, uint8_t ErrorCode))&USB_LDD_USB_LDD_OnDeviceError
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceReset=(void (*)(LDD_TUserData *UserDataPtr))&USB_LDD_USB_LDD_OnDeviceReset
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceResume=(void (*)(LDD_TUserData *UserDataPtr))&USB_LDD_USB_LDD_OnDeviceResume
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSetupPacket=(void (*)(LDD_TUserData *UserDataPtr, uint8_t EpNum))&USB_LDD_USB_LDD_OnDeviceSetupPacket
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSof=(void (*)(LDD_TUserData *UserDataPtr, uint16_t FrameNumber))&USB_LDD_USB_LDD_OnDeviceSof
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSpeedDetect=(void (*)(LDD_TUserData *UserDataPtr, LDD_USB_TBusSpeed CurrentSpeed))&USB_LDD_USB_LDD_OnDeviceSpeedDetect
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSuspend=(void (*)(LDD_TUserData *UserDataPtr))&USB_LDD_USB_LDD_OnDeviceSuspend
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHost1msTimer=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostDeviceDeattach=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostError=(void (*)(LDD_TUserData *UserDataPtr, uint8_t ErrorSource, uint8_t ErrorCode))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostResetRecovery=(void (*)(LDD_TUserData *UserDataPtr, LDD_USB_TBusSpeed CurrentSpeed))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostResumeRecovery=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgDevice=(void (*)(LDD_TUserData *UserDataPtr, bool Enabled))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgHost=(void (*)(LDD_TUserData *UserDataPtr, bool Enabled))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgStateChange=(void (*)(LDD_TUserData *UserDataPtr, LDD_USB_Otg_TState NewState))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnSignalChange=(void (*)(LDD_TUserData *UserDataPtr, LDD_TPinMask SignalMask, LDD_TPinMask SignalValue))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Deinit=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceAssertResume=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceCancelTransfer=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceDeinitEndpoint=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceGetTransferStatus=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceGetUsbStatus=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceInitEndpoint=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceReadSetupData=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceRecvData=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceSendData=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceSetAddress=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceSetUsbStatus=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceStallEndpoint=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceUnstallEndpoint=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Disable=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Enable=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Init=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_ConnectPin=(LDD_TError (*)(LDD_TDeviceDataPtr *DeviceData, LDD_TPinMask PinMask))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Deinit=(void (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_Deinit
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceAssertResume=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_DeviceAssertResume
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceCancelTransfer=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))&USB_LDD_DeviceCancelTransfer
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceDeinitEndpoint=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))&USB_LDD_DeviceDeinitEndpoint
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceGetTransferStatus=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))&USB_LDD_DeviceGetTransferStatus
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceGetUsbStatus=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t *CmdStatusPtr))&USB_LDD_DeviceGetUsbStatus
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceInitEndpoint=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_TEpDescriptor *EpDescriptorPtr, uint8_t Flags))&USB_LDD_DeviceInitEndpoint
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceReadSetupData=(void (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, LDD_USB_TSDP *SDPPtr))&USB_LDD_DeviceReadSetupData
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceRecvData=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr))&USB_LDD_DeviceRecvData
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSendData=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr))&USB_LDD_DeviceSendData
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSetAddress=(void (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t Address))&USB_LDD_DeviceSetAddress
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSetUsbStatus=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t Cmd))&USB_LDD_DeviceSetUsbStatus
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceStallEndpoint=(void (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))&USB_LDD_DeviceStallEndpoint
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceUnstallEndpoint=(void (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))&USB_LDD_DeviceUnstallEndpoint
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Disable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_Disable
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Enable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_Enable
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_GetDriverState=(LDD_TDriverState (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_GetEventMask=(LDD_TEventMask (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostCancelTransfer=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeHandlePtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostClosePipe=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetFrameNumber=(uint16_t (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetMicroFrameNumber=(uint8_t (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetPortState=(LDD_USB_Host_TState (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetTransferStatus=(LDD_USB_TTransferState (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TTransferHandle *TransferHandlePtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostOpenPipe=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeInitParamsPtr, LDD_USB_Host_TPipeHandle **PipeHandlePtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostRecvData=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSendData=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSendSetup=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSetPortState=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPortControlCmd Cmd))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Init=(LDD_TDeviceData * (*)(LDD_TUserData *UserDataPtr))&USB_LDD_Init
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Main=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgCmd=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Otg_TCmd Cmd))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgRegisterDevice=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgRegisterHost=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetEventMask=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetOperationMode=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetSignal=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TPinMask SignalMask, LDD_TPinMask SignalValue))0
PE_G_USE_UINTXX_T=
PE_ProductVersion=10.0
PEversion=05.03
PEversionDecimal=1283
ProcessorModule=Cpu
ProcessorName=Cpu
ProjectModule=ProcessorExpert
ProjectName=ProcessorExpert
ServerDir_PE=D:\FreeScale\CW MCU v10.3_B121029\MCU\ProcessorExpert\
SetHighSpeedMode=
SupportedCPUfamily=
TimeStamp=2012-11-19, 15:20, # CodeGen: 25
Xtal_kHz=4000
Xtal_kHz_real=4000
ivINT_USB0=USB_LDD_USB_Interrupt
virtual_ADC0_TotalConversionPrescalerAddr=1073983496
virtual_ADC0_TotalConversionPrescalerReg=ADC0_CFG1

 DEPRECATED GLOBAL SYMBOLS (alphabet order)
-------------------------------------------
ADC0AsynchroClockAddr=null
ADC0AsynchroClockReg=null
ADC0BusClockAddr=null
ADC0BusClockReg=null
ADC0ClkSelAddr=null
ADC0ClkSelReg=null
ActiveConfigIdentifier=null
ActiveConfiguration=null
CPUDB_BUS_FREQ_HZ_MAX=null
CPUDB_CPU_MASTER=null
CPUDB_CW_MCU_ID=null
CPUDB_CW_MCU_NAME=null
CPUDB_LQFP80=null
CPUDB_MKL25Z128xxx4=null
CPUDB_MKL25Z4=null
CPUDB_PACKAGE=null
CPUDB_PLL_INPUT_FREQ_HZ_MAX=null
CPUDB_PLL_INPUT_FREQ_HZ_MIN=null
CPUDB_PLL_OUTPUT_FREQ_HZ_MAX=null
CPUDB_PLL_OUTPUT_FREQ_HZ_MIN=null
CPUDB_ProgramFlashBlockCount=null
CPUDB_ProgramFlashEraseUnitSize=null
CPUDB_ProgramFlashSize=null
CPUDB_ProgramFlashWriteUnitSize=null
CPUDB_SYSTEM_FREQ_HZ_MAX=null
CPU_DB_version=null
CPUendian=null
CPUfamily=null
CPUproducer=null
CPUrunSpeedModeNum=null
CPUsubFamily=null
CPUtype=null
CPUvariant=null
ClientDir_Binary=null
ClientDir_Code=null
ClientDir_PE=null
ClientDir_Project=null
CommentBrackets=null
Compiler=null
CompilerID=null
DirRel_Binary=null
DirRel_BinaryToEvents=null
DirRel_Code=null
DirRel_Docs=null
DirRel_EventToBinary=null
DirRel_Events=null
DirRel_ProjectSettings=null
EclipseProjectName=null
InterruptTableType=null
Language=null
Not_for_MPC512x=null
OnChipEEPROM=null
OnChipFLASH=null
OnChipRAM=null
PE_DEBUG=null
PE_DEVELOPMENT=null
PE_ECLIPSE=null
PE_GENERATING=null
PE_G_CPUCFG_AutoIncludeIO_Map=null
PE_G_CPUCFG_EntryPointFunctionName=null
PE_G_CPUCFG_EntryPointFunctionReturn=null
PE_G_CPUCFG_EntryPointFunctionReturnType=null
PE_G_CPUCFG_GenerateLinkerFile=null
PE_G_CPUCFG_GenerateMainModule=null
PE_G_CPUCFG_InitIntVectorTableSym=null
PE_G_CPUCFG_ManageInterruptVectorTable=null
PE_G_GenBitMask=null
PE_G_InternalMethodDescriptionNotFound=null
PE_G_MisraCnfBackParams_0=null
PE_G_MisraCnfParams_0=null
PE_G_MisraRuleList_0=null
PE_G_MisraStackIdx=null
PE_G_NO_SETREGMACROS=null
PE_G_RTOSAdap_regCompIndex=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDevice1msTimer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceError=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceReset=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceResume=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceSetupPacket=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceSof=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceSpeedDetect=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnDeviceSuspend=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDevice1msTimer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceError=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceReset=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceResume=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSetupPacket=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSof=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSpeedDetect=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSuspend=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHost1msTimer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostDeviceDeattach=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostError=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostResetRecovery=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostResumeRecovery=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgDevice=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgHost=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgStateChange=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnSignalChange=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Deinit=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceAssertResume=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceCancelTransfer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceDeinitEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceGetTransferStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceGetUsbStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceInitEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceReadSetupData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceRecvData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceSendData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceSetAddress=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceSetUsbStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceStallEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_DeviceUnstallEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Disable=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Enable=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Init=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_ConnectPin=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Deinit=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceAssertResume=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceCancelTransfer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceDeinitEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceGetTransferStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceGetUsbStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceInitEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceReadSetupData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceRecvData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSendData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSetAddress=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSetUsbStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceStallEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceUnstallEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Disable=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Enable=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_GetDriverState=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_GetEventMask=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostCancelTransfer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostClosePipe=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetFrameNumber=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetMicroFrameNumber=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetPortState=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetTransferStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostOpenPipe=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostRecvData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSendData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSendSetup=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSetPortState=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Init=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Main=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgCmd=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgRegisterDevice=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgRegisterHost=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetEventMask=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetOperationMode=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetSignal=null
PE_G_USE_UINTXX_T=null
PE_ProductVersion=null
PEversion=null
PEversionDecimal=null
ProcessorModule=null
ProcessorName=null
ProjectModule=null
ProjectName=null
ServerDir_PE=null
SetHighSpeedMode=null
SupportedCPUfamily=null
TimeStamp=null
Xtal_kHz=null
Xtal_kHz_real=null
ivINT_USB0=null
virtual_ADC0_TotalConversionPrescalerAddr=null
virtual_ADC0_TotalConversionPrescalerReg=null

 GLOBAL LISTS (alphabet order)
-------------------------------------------
ADC0AsynchroClock=[1]
ADC0AsynchroClock_Setting=[ADC0Async_FullPower_HighSpeed]
ADC0BusClock=[1]
ADC0BusClock_Setting=[1]
ADC0ClkSel=[1]
ADC0ClkSel_Setting=[ADC0BusClock]
COPClkSelect=[1]
COPClkSelect_Setting=[COPBusClock]
ERCLK32KSel=[1]
ERCLK32KSel_Setting=[SYSTEM_OSC]
EventModuleList=[Events]
I2C0_LoTimeoutClkSel=[1]
I2C0_LoTimeoutClkSel_Setting=[I2C0_LoTimeout_BusClkDiv64]
I2C1_LoTimeoutClkSel=[1]
I2C1_LoTimeoutClkSel_Setting=[I2C1_LoTimeout_BusClkDiv64]
IRCLKSel=[1]
IRCLKSel_Setting=[IRC_32kHz]
IncludeSharedModules=[PE_Types|PE_Error|PE_Const|IO_Map]
InstructionClock=[undef]
LPTMR0_ClockSelect=[1]
LPTMR0_ClockSelect_Setting=[ERCLK]
MCGOUTSel=[1]
MCGOUTSel_Setting=[MCGPLLCLK]
MCG_FLL_MFactor=[640]
MCG_FLL_MFactor_Setting=[640]
MCG_FLL_RCLKSel=[1]
MCG_FLL_RCLKSel_Setting=[MCG_FRDIV]
MCG_FRDIV=[256]
MCG_FRDIV_Setting=[256]
MCG_PRDIV=[2]
MCG_PRDIV_Setting=[2]
MCG_VDIV=[24]
MCG_VDIV_Setting=[24]
ModuleList=[usb_audio|usb_device|USB_LDD]
OUTDIV1Presc=[2]
OUTDIV1Presc_Setting=[2]
OUTDIV4Presc=[2]
OUTDIV4Presc_Setting=[2]
PE_G_RTOSAdap_regCompInstanceAllocatedDevices=[USB0]
PE_G_RTOSAdap_regCompInstanceDeviceBaseAddrs=[1074208768]
PE_G_RTOSAdap_regCompInstanceIds=[0]
PE_G_RTOSAdap_regCompInstanceNames=[USB_LDD]
PE_G_RTOSAdap_regCompInstanceSharedComponentName=[USB_LDD]
PE_G_RTOSAdap_regCompInstanceTypes=[USB_LDD]
PE_G_RTOSAdap_regCompInstance_USB_LDD_events=[OnDeviceReset|OnDeviceSpeedDetect|OnDeviceSuspend|OnDeviceResume|OnDeviceSetupPacket|OnDeviceSof|OnDeviceError|OnDevice1msTimer|OnHostDeviceDeattach|OnHostResetRecovery|OnHostResumeRecovery|OnHostError|OnHost1msTimer|OnOtgDevice|OnOtgHost|OnOtgStateChange|OnSignalChange]
PE_G_RTOSAdap_regCompInstance_USB_LDD_methods=[Init|Deinit|SetEventMask|GetEventMask|Enable|Disable|DeviceGetUsbStatus|DeviceSetUsbStatus|DeviceSetAddress|DeviceAssertResume|DeviceInitEndpoint|DeviceDeinitEndpoint|DeviceStallEndpoint|DeviceUnstallEndpoint|DeviceReadSetupData|DeviceSendData|DeviceRecvData|DeviceGetTransferStatus|DeviceCancelTransfer|HostGetPortState|HostSetPortState|HostGetFrameNumber|HostGetMicroFrameNumber|HostOpenPipe|HostClosePipe|HostSendSetup|HostSendData|HostRecvData|HostGetTransferStatus|HostCancelTransfer|OtgRegisterDevice|OtgRegisterHost|OtgCmd|SetSignal|ConnectPin|Main|SetOperationMode|GetDriverState]
PLLFLLSel=[1]
PLLFLLSel_Setting=[MCGPLLCLKDIV2]
SPI0_BaudRatePrescDiv=[1]
SPI0_BaudRatePrescDiv_Setting=[1]
SPI1_BaudRatePrescDiv=[1]
SPI1_BaudRatePrescDiv_Setting=[1]
SharedModules=[Kinetis\PE_Types.drv|Kinetis\PE_Error.drv|Kinetis\PE_Const.drv|Kinetis\IO_Map.drv]
SpeedModeList=[SpeedMode0]
SpeedModeNames=[SpeedMode0|SpeedMode1|SpeedMode2|SpeedMode3|SpeedMode4|SpeedMode5|SpeedMode6|SpeedMode7]
SystemPrescaler=[1]
SystemPrescaler_Setting=[1]
TPMClk=[1]
TPMClk_Setting=[PLLFLLSelDistr]
UART0_ClkSel=[1]
UART0_ClkSel_Setting=[PLLFLLSelDistr]
UART0_Divider=[4]
UART0_Divider_Setting=[4]
USB0_ClkSel=[1]
USB0_ClkSel_Setting=[USB0_PLLFLL0]
virtual_ADC0_TotalConversionPrescaler=[1]
virtual_ADC0_TotalConversionPrescaler_Setting=[1]

{{DEVELOPMENT}} --------(((DEBUGINFO)))--------.{{DEVELOPMENT}} 


#endif /* __PE_Types_H */
