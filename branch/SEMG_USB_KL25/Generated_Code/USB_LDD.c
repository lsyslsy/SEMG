/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : USB_LDD.c
**     Project     : ProcessorExpert
**     Processor   : MKL25Z128VLK4
**     Component   : USB_LDD
**     Version     : Component 01.307, Driver 01.09, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2014-11-11, 16:42, # CodeGen: 43
**     Abstract    :
**         This component implements an low level USB API.
**     Settings    :
**          Component name                                 : USB_LDD
**          USB module (SIE)                               : USB0
**          Input clock frequency [MHz]                    : 48 MHz
**          Interrupt service/event                        : Enabled
**            Interrupt                                    : INT_USB0
**            Interrupt priority                           : medium priority
**          Mode                                           : DEVICE
**            Transceiver type                             : Internal
**              Transceiver module                         : USB0_FS
**              Transceiver weak pull-downs                : Enabled
**              USB revision                               : USB 2.0
**              Device data rate                           : Full speed
**              Pin/signal setting                         : 
**                Clock pin                                : Disabled
**                USB data pins                            : 
**                  Data plus                              : 
**                    Pin                                  : USB0_DP
**                    Pin signal                           : 
**                  Data minus                             : 
**                    Pin                                  : USB0_DM
**                    Pin signal                           : 
**                VBUS pins                                : 
**                  VBUS detect                            : Disabled
**                Pullup/Pulldown pins                     : 
**                  DP pullup                              : Enabled
**                    Pin                                  : USB0_Internal_DP_PU
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  DM pullup                              : Disabled
**            Device mode setting                          : 
**              EP list                                    : 16
**                EP 0                                     : Enabled
**                  Control transfer                       : Enabled
**                    Maximum packet size                  : 32
**                    Max. queue size                      : 1
**                  Bulk OUT transfer                      : Disabled
**                  Bulk IN transfer                       : Disabled
**                  Interrupt OUT transfer                 : Disabled
**                  Interrupt IN transfer                  : Disabled
**                  Isochronous OUT  transfer              : Disabled
**                  Isochronous IN  transfer               : Disabled
**                EP 1                                     : Enabled
**                  Control transfer                       : Disabled
**                  Bulk OUT transfer                      : Disabled
**                  Bulk IN transfer                       : Disabled
**                  Interrupt OUT transfer                 : Disabled
**                  Interrupt IN transfer                  : Disabled
**                  Isochronous OUT  transfer              : Disabled
**                  Isochronous IN  transfer               : Enabled
**                    Max. packet size                     : 1023
**                    Max. queue size                      : 1
**                EP 2                                     : Disabled
**                EP 3                                     : Disabled
**                EP 4                                     : Disabled
**                EP 5                                     : Disabled
**                EP 6                                     : Disabled
**                EP 7                                     : Disabled
**                EP 8                                     : Disabled
**                EP 9                                     : Disabled
**                EP 10                                    : Disabled
**                EP 11                                    : Disabled
**                EP 12                                    : Disabled
**                EP 13                                    : Disabled
**                EP 14                                    : Disabled
**                EP 15                                    : Disabled
**            Initialization                               : 
**              Enabled in init. code                      : no
**              Auto initialization                        : no
**              Event mask                                 : 
**                OnDeviceReset                            : Enabled
**                OnDeviceSpeedDetect                      : Enabled
**                OnDeviceSuspend                          : Enabled
**                OnDeviceResume                           : Enabled
**                OnDeviceSetupPacket                      : Enabled
**                OnDeviceSof                              : Enabled
**                OnDeviceError                            : Enabled
**                OnDevice1msTimer                         : Enabled
**                OnSignalChange                           : Enabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init                    - LDD_TDeviceData * USB_LDD_Init(LDD_TUserData *UserDataPtr);
**         Deinit                  - void USB_LDD_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         Enable                  - LDD_TError USB_LDD_Enable(LDD_TDeviceData *DeviceDataPtr);
**         Disable                 - LDD_TError USB_LDD_Disable(LDD_TDeviceData *DeviceDataPtr);
**         DeviceGetUsbStatus      - LDD_TError USB_LDD_DeviceGetUsbStatus(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceSetUsbStatus      - LDD_TError USB_LDD_DeviceSetUsbStatus(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceSetAddress        - void USB_LDD_DeviceSetAddress(LDD_TDeviceData *DeviceDataPtr, uint8_t Address);
**         DeviceAssertResume      - LDD_TError USB_LDD_DeviceAssertResume(LDD_TDeviceData *DeviceDataPtr);
**         DeviceInitEndpoint      - LDD_TError USB_LDD_DeviceInitEndpoint(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceDeinitEndpoint    - LDD_TError USB_LDD_DeviceDeinitEndpoint(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceStallEndpoint     - void USB_LDD_DeviceStallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         DeviceUnstallEndpoint   - void USB_LDD_DeviceUnstallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         DeviceReadSetupData     - void USB_LDD_DeviceReadSetupData(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         DeviceSendData          - LDD_TError USB_LDD_DeviceSendData(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceRecvData          - LDD_TError USB_LDD_DeviceRecvData(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceGetTransferStatus - LDD_TError USB_LDD_DeviceGetTransferStatus(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceCancelTransfer    - LDD_TError USB_LDD_DeviceCancelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**
**     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
**     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/
/*!
** @file USB_LDD.c
** @version 01.09
** @brief
**         This component implements an low level USB API.
*/         
/*!
**  @addtogroup USB_LDD_module USB_LDD module documentation
**  @{
*/         

/* MODULE USB_LDD. */

#include "usb_device.h"
#include "USB_LDD.h"
/* {Default RTOS Adapter} No RTOS includes */
#include "USB_PDD.h"

#define USB_LDD_AVAILABLE_IN_SIGNALS_MASK ((LDD_TPinMask)(0x00U))

#define USB_LDD_IN_SIGNALS_INIT_VALUE ((LDD_TPinMask)(0x00U))

/* BD Endpoint control access macros */
#define USB_LDD_BD_OWM                            0x00000080U
#define USB_LDD_BD_DATA0                          0x00000000U
#define USB_LDD_BD_DATA1                          0x00000040U
#define USB_LDD_BD_KEEP                           0x00000020U
#define USB_LDD_BD_NINC                           0x00000010U
#define USB_LDD_BD_DTS                            0x00000008U
#define USB_LDD_BD_STALL                          0x00000004U

#define USB_LDD_BD_PID_BUS_TIMEOUT                0x00000000U
#define USB_LDD_BD_PID_DATA0                      0x0000000CU
#define USB_LDD_BD_PID_DATA1                      0x0000002CU
#define USB_LDD_BD_PID_ACK                        0x00000008U
#define USB_LDD_BD_PID_STALL                      0x00000038U
#define USB_LDD_BD_PID_NACK                       0x00000028U
#define USB_LDD_BD_PID_DATA_ERROR                 0x0000003CU
#define USB_LDD_BD_PID_MASK                       0x0000003CU

#define USB_LDD_BD_LE_OWM                         0x80000000U
#define USB_LDD_BD_LE_DATA1                       0x40000000U
#define USB_LDD_BD_LE_STALL                       0x04000000U

/* =============================================================================
**    |  Endpoint   |           EP0           |            EP1          |    ...
**    |   EP_IDX    |    OUT     |    IN      |    OUT     |    IN      |    ...
**    |   BD_IDX    | odd | even | odd | even | odd | even | odd | even |    ...
** ============================================================================ */
#define MAX_EP_IDX                                0x03u
#define MAX_BD_IDX                                0x07u

#define USB_LDD_DEVICE_WAKE_UP_READY_TIME         0x06 /* Number of ms the bus must be idle to force wake-up signaling */
#define USB_LDD_DEVICE_SUSPEND_DETECTION_TIME     0x03 /* Number of milliseconds from last EOP to detect IDLE */
#define USB_LDD_DEVICE_RESUME_DURATION            0x05 /* Number of milliseconds from last EOP to detect SUSPEND */
#define USB_LDD_DEVICE_RESUME_DETECTED            0x07 /* Constants specify that non IDLE state during suspend has been detected */
#define USB_LDD_A_WAIT_VRISE_TIME_OUT_MS          0x64
#define USB_LDD_A_WAIT_BCON_SHORT_DEBOUCE_MS      0x01
#define USB_LDD_A_WAIT_BCON_LONG_DEBOUCE_MS       0x64
#define USB_LDD_A_WAIT_BCON_TIME_OUT_MS           0x044C
#define USB_LDD_A_IDLE_BDIS_TIME_OUT_MS           0xC8
#define USB_LDD_B_ASE0_TIME_OUT_MS                0x9B
#define USB_LDD_B_SE0_SRP_TIME_OUT_MS             0x03
#define USB_LDD_B_DATA_PLS_TIME_OUT_MS            0x07

/* OTG input variables */
#define USB_LDD_OTG_TIMEOUT                       0x80000000u
#define USB_LDD_OTG_1MS_TIMEOUT                   0x40000000u
#define USB_LDD_OTG_A_BUS_RESUME                  0x20000000u
#define USB_LDD_OTG_A_BUS_SUSPEND                 0x10000000u
#define USB_LDD_OTG_A_CONN                        0x08000000u
#define USB_LDD_OTG_A_SESSION_VALID               0x08u
#define USB_LDD_OTG_A_SRP_DET                     0x04000000u
#define USB_LDD_OTG_A_VBUS_VALID                  0x01u
#define USB_LDD_OTG_B_BUS_RESUME                  0x02000000u
#define USB_LDD_OTG_B_BUS_SUSPEND                 0x01000000u
#define USB_LDD_OTG_B_CONN                        0x00800000u
#define USB_LDD_OTG_B_SE0_SRP                     0x00400000u
#define USB_LDD_OTG_B_SESSION_VALID               0x08u
#define USB_LDD_OTG_B_SESSION_END                 0x04u
#define USB_LDD_OTG_ID                            0x80u

#define USB_LDD_OTG_VBUS_VALID                    0x01u
#define USB_LDD_OTG_SESSION_VALID                 0x08u

/* Informative variables */
#define USB_LDD_OTG_A_BUS_DROP                    0x00200000u
#define USB_LDD_OTG_A_BUS_REQ                     0x00100000u
#define USB_LDD_OTG_A_CLR_ERR                     0x00080000u
#define USB_LDD_OTG_A_SUSPEND_REQ                 0x00040000u
#define USB_LDD_OTG_B_BUS_REQ                     0x00020000u

/* Internal variables */
#define USB_LDD_TIMEOUT                           0x02u
#define USB_LDD_1MS_TIMEOUT                       0x40u
#define USB_LDD_OTG_A_SET_B_HNP_EN                0x00010000u
#define USB_LDD_OTG_B_SRP_DONE                    0x8000u
#define USB_LDD_OTG_B_HNP_EN                      0x4000u
#define USB_LDD_OTG_NOT_SE0                       0x2000u

#define USB_LDD_DEVICE_VBUS_DETECT                0x04u
#define USB_LDD_HOST_VBUS_OVERCURRENT             0x04u

#define USB_LDD_EnableTimer() USB_PDD_Enable1msInterrupt(USB0_BASE_PTR)

/* Buffer descriptor table item structure */
typedef struct USB_LDD_TBD_Struct {
  uint32_t                        CtrlReg;
  uint32_t                        BufferPtr;
} USB_LDD_TBD;

/* Transfer descriptor structure */
typedef struct USB_LDD_TTD_Struct {
  bool                             Active;
  bool                             ZLT;
  struct USB_LDD_TTD_Struct       *pNextTD;
  uint8_t                         *BufferPtr;
  uint16_t                         RemainingData;
  LDD_USB_Device_TTD              *UserTDPtr;
} USB_LDD_TTD;

typedef enum {
  USB_LDD_EP_NOT_AVAILABLE         = 0x00U, /* Endpoint is not supported by the driver */
  USB_LDD_EP_NOT_CONFIGURED        = 0x01U, /* Endpoint is not enabled by the Host */
  USB_LDD_EP_STALLED               = 0x02U, /* Endpoint is stalled */
  USB_LDD_EP_IDLE                  = 0x04U, /* Endpoint is idle */
  USB_LDD_EP_BUSY                  = 0x08U  /* Endpoint is busy */
} USB_LDD_TePState;

typedef enum {
  USB_LDD_CONTROL_NO_DATA,
  USB_LDD_CONTROL_NO_DATA_HSK,
  USB_LDD_CONTROL_READ_DATA,
  USB_LDD_CONTROL_READ_HSK,
  USB_LDD_CONTROL_WRITE_DATA,
  USB_LDD_CONTROL_WRITE_HSK
} USB_LDD_TCtrlTransferStage;

/* Endpoint private data structure */
typedef struct USB_LDD_TEpData_Struct {
  USB_LDD_TePState                 EpState;      /* EP state */
  uint8_t                          EpNumber;     /* EP number */
  LDD_USB_TTransferType            TransferType; /* EP Transfer type */
  uint16_t                         MaxPacketSize; /* EP max. packet size */
  union {
    struct {
      uint16_t                     ReqDataSize;
      USB_LDD_TCtrlTransferStage   Stage;
    } Ctrl;
  } TT;
  bool                             ZLT;
  USB_LDD_TTD                     *TDQueuePtr;   /* Address of the TD queue */
  USB_LDD_TTD                     *pCurrentTD;   /* Address of the first TD */
  USB_LDD_TTD                     *pLastTD;      /* Address of the last TD */
  LDD_USB_TSDP                    *SDPPtr;       /* Address of the local buffer for SETUP packet */
  volatile uint8_t                *EpCtrlRegPtr; /* Address of theEP control register for this EP */
  uint32_t                         BDCtrlRegVal; /* Predefined value for EP control register */
  USB_LDD_TBD                     *BDPtr;        /* Address of the BD item for this EP */
  USB_LDD_TBD                     *LastTrBDPtr;  /* Address of the last transaction BD item for this EP */
} USB_LDD_TEpData;


/* Device data structure */
typedef struct USB_LDD_TDeviceData_Struct {
  USB_LDD_TBD                      BDT[MAX_BD_IDX + 0x01u]; /* BD array */
  LDD_USB_Device_TState            DeviceState;  /* Internal device engine state */
  LDD_USB_Device_TState            LastDeviceState; /* State before entering suspend mode */
  USB_LDD_TEpData                  EpData[MAX_EP_IDX + 0x01u]; /* EP data array */
  USB_LDD_TTD                      EP_0_OUT_dTD_Queue[0x01U];
  USB_LDD_TTD                      EP_0_IN_dTD_Queue[0x01U];
  uint8_t                          EP_0_Control_PacketBuffer[0x20U];
  USB_LDD_TTD                      EP_1_IN_dTD_Queue[0x01U];
  LDD_TUserData                   *UserDeviceDataPtr; /* Device mode user device data structure */
  bool                             ISR;          /* TRUE if ISR is in progress */
  bool                             EnUser;       /* Enable/Disable device state variable */
  uint32_t                         InSignalsState; /* Input signals state variable */
  int32_t                          msCounter;    /* 1ms counter */
} USB_LDD_TDeviceData, *USB_LDD_TDeviceDataPtr;

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static USB_LDD_TDeviceData DevDataPtr__DEFAULT_RTOS_ALLOC __attribute__ ((aligned (512)));
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static USB_LDD_TDeviceDataPtr INT_USB0__DEFAULT_RTOS_ISRPARAM;
static void USB_LDD_StartTimer(USB_LDD_TDeviceData *DevDataPtr, int32_t Timeout);

/*
** ===================================================================
**     Method      :  USB_LDD_UsbLock (component USB_LDD)
**
**     Description :
**         USB lock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_UsbLock(USB_LDD_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_UsbUnlock (component USB_LDD)
**
**     Description :
**         USB unlock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_UsbUnlock(USB_LDD_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_StartTimer (component USB_LDD)
**
**     Description :
**         Starts timer.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_StartTimer(USB_LDD_TDeviceData *DevDataPtr, int32_t Timeout)
{
  DevDataPtr->msCounter = Timeout;                         /* Remember timeout */
  USB_LDD_EnableTimer();                                   /* Enable timer */
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceQueueDataPacket (component USB_LDD)
**
**     Description :
**         Prepares data packet(s) to be sent/received. Initializes all 
**         free BDT entry to transmit requested data.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceQueueDataPacket(USB_LDD_TEpData *EpDataPtr, USB_LDD_TTD *TDPtr) {
  uint16_t                         PacketSize;
  USB_LDD_TBD                     *BDPtr;

  do {
    BDPtr = EpDataPtr->BDPtr;
    if ((BDPtr->CtrlReg & USB_LDD_BD_LE_OWM) != 0x00U) { /* Is BDT entry free? */
      return;                          /* No, packet will be queued as soon as some entry is freed */
    }
    PacketSize = TDPtr->RemainingData; /* Compute max packet size */
    if (PacketSize > EpDataPtr->MaxPacketSize) { /* Remaining data size > then Max packet size? */
      PacketSize = EpDataPtr->MaxPacketSize; /* Yes, send 'MaxPacketSize' length packet */
    }
    BDPtr->BufferPtr = (uint32_t)TDPtr->BufferPtr; /* Set buffer address */
    BDPtr->CtrlReg = ((uint32_t)PacketSize << 0x10U) | EpDataPtr->BDCtrlRegVal; /* Set packet size and put this entry to the SIE */
    EpDataPtr->BDPtr = (USB_LDD_TBD *)((uint32_t)(EpDataPtr->BDPtr) ^ 0x08U); /* Switch to the next BD */
    EpDataPtr->BDCtrlRegVal ^= USB_LDD_BD_DATA1; /* Toggle data for next packet */
    TDPtr->RemainingData -= PacketSize; /* Adjust remaining data count */
    TDPtr->BufferPtr += PacketSize;    /* Adjust data pointer */
    EpDataPtr->pCurrentTD = TDPtr;     /* Mark TD as current TD */
  } while (0x00);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceReceiveSetupPacket (component USB_LDD)
**
**     Description :
**         Prepares buffer for setup packet
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceReceiveSetupPacket(USB_LDD_TEpData *EpDataPtr)
{
  USB_LDD_TTD                     *TDPtr = EpDataPtr->TDQueuePtr;

  TDPtr->Active = TRUE;
  TDPtr->ZLT = FALSE;
  TDPtr->BufferPtr = (uint8_t*)(void*)EpDataPtr->SDPPtr;
  TDPtr->RemainingData = (uint16_t)0x08U;
  USB_LDD_DeviceQueueDataPacket(EpDataPtr,TDPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceQueueTransfer (component USB_LDD)
**
**     Description :
**         Inserts Transfer descriptor to the TD queue
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError USB_LDD_DeviceQueueTransfer(USB_LDD_TDeviceData *DevDataPtr, LDD_USB_Device_TTD *UserTDPtr, uint32_t EpDir)
{
  USB_LDD_TTD                     *NewTDPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;
  bool                             RecvSetup = FALSE;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)UserTDPtr->Head.EpNum << 0x01U)]; /* Get address of EPx OUT data structure */
  if (EpDir != LDD_USB_DIR_OUT) {                          /* EPx IN is next item in the array */
    EpDataPtr++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX + 0x01u]) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  if (EpDataPtr->EpState < USB_LDD_EP_IDLE) {              /* Is EP ready for transmission? */
    if (((uint32_t)EpDataPtr->EpState & (uint32_t)USB_LDD_EP_STALLED) != 0x00U) { /* No, is EP stalled? */
      Res = ERR_FAILED;                                    /* EP is stalled, return with error */
    } else {
      Res = ERR_NOTAVAIL;                                  /* EP is not enabled,  return with error */
    }
  } else {
    NewTDPtr = EpDataPtr->pLastTD->pNextTD;                /* Find empty TD */
    if (NewTDPtr->Active) {                                /* If TD is active or completed with error */
      Res = ERR_QFULL;                                     /* the ring queue is full, return with error */
    } else {
      NewTDPtr->BufferPtr = (uint8_t *)UserTDPtr->Head.BufferPtr; /* Remember buffer address */
      NewTDPtr->RemainingData = UserTDPtr->Head.BufferSize; /* Remember buffer size */
      if (EpDataPtr->TransferType == LDD_USB_CONTROL) {    /* Control transfer? */
        switch (EpDataPtr->TT.Ctrl.Stage) {
          case USB_LDD_CONTROL_READ_HSK:
            /* Control read - handshake stage (Rx) */
            RecvSetup = TRUE;                              /* Be ready to receive new setup data packet after HSK is received */
            break;
          case USB_LDD_CONTROL_WRITE_DATA:
            /* Control write - data stage (Rx) */
            if (NewTDPtr->RemainingData >= EpDataPtr->TT.Ctrl.ReqDataSize) { /* Greater buffer then the data sent by the Host? */
              NewTDPtr->RemainingData = EpDataPtr->TT.Ctrl.ReqDataSize; /* Yes, receive all data send by the host */
            }
            NewTDPtr->ZLT = FALSE;                         /* No ZLT */
            break;
          case USB_LDD_CONTROL_READ_DATA:
            /* Control read - data stage (Rx) */
            if (NewTDPtr->RemainingData >= EpDataPtr->TT.Ctrl.ReqDataSize) { /* More data then the Host expects? */
              NewTDPtr->RemainingData = EpDataPtr->TT.Ctrl.ReqDataSize; /* Yes, send only requested data size */
              NewTDPtr->ZLT = FALSE;                       /* No ZLT */
            } else {
              NewTDPtr->ZLT = TRUE;                        /* Sent zero-length packet if packet size is multiple of MaxPacketSize */
            }
            break;
          case USB_LDD_CONTROL_WRITE_HSK:
          case USB_LDD_CONTROL_NO_DATA_HSK:
            /* Control write/no-data - handshake stage (Tx) */
            USB_LDD_DeviceReceiveSetupPacket(EpDataPtr-1); /* Be ready to receive setup data packet after HSK is sent */
            break;
          default:
            break;
        }
      } else {                                             /* Non-control transfer */
        if ((UserTDPtr->Head.Flags & LDD_USB_DEVICE_TRANSFER_FLAG_ZLT) != 0x00U) {
          NewTDPtr->ZLT = TRUE;                            /* Sent zero-length packet if packet size is multiple of MaxPacketSize */
        } else {
          NewTDPtr->ZLT = EpDataPtr->ZLT;                  /* Default EP ZLT */
        }
      }
      if ((UserTDPtr->Head.Flags & (uint32_t)LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM) != 0x00U) { /* Additional transfer params? */
        /* If additional transfer params are requested the user TD must not be */
        /* released until the callback is called or the transfer state        */
        /* is LDD_USB_TRANSFER_PENDING */
        NewTDPtr->UserTDPtr = UserTDPtr;                   /* Remember transfer descriptor address? */
        UserTDPtr->TransmittedDataSize = 0x00U;            /* No data transmitted yet */
        UserTDPtr->TransferState = LDD_USB_TRANSFER_PENDING; /* Transfer is pending */
      } else {
        NewTDPtr->UserTDPtr = NULL;
      }
      NewTDPtr->Active = TRUE;                             /* Set transfer size and active bit */
      EpDataPtr->pLastTD = NewTDPtr;                       /* Update last TD pointer */
      USB_LDD_DeviceQueueDataPacket(EpDataPtr,NewTDPtr);   /* Queue transfer */
      if (RecvSetup) {                                     /* Control read handshake stage? */
        USB_LDD_DeviceReceiveSetupPacket(EpDataPtr);       /* Receive new setup data packet */
      }
      Res = ERR_OK;
    }
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return(Res);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceDataPacketDone (component USB_LDD)
**
**     Description :
**         Transaction done handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceDataPacketDone(USB_LDD_TDeviceData *DevDataPtr, USB_LDD_TEpData *EpDataPtr, uint16_t PacketSize)
{
  USB_LDD_TTD                     *TDPtr;
  LDD_USB_Device_TTD              *UserTDPtr;

  TDPtr     = EpDataPtr->pCurrentTD;
  UserTDPtr = TDPtr->UserTDPtr;
  if (UserTDPtr != NULL) {                                 /* Extended transfer parameters? */
    UserTDPtr->TransmittedDataSize += (uint16_t)PacketSize; /* Yes, update transmitted data counter */
  }
  if (PacketSize < EpDataPtr->MaxPacketSize) {             /* Short(zero-length) packet transmitted? */
     TDPtr->Active = FALSE;                                /* Yes, transfer is done */
  } else {                                                 /* Max. size packet transmitted */
    if (TDPtr->RemainingData == 0x00U) {                   /* All data transmitted? */
      if (TDPtr->ZLT == FALSE) {                           /* Yes, ZLT requested (ZLT can be TRUE only for Tx)? */
        TDPtr->Active = FALSE;                             /* No, transfer is done */
      }
    }
  }
  if (TDPtr->Active == FALSE) {                            /* Transfer done? */
    if (UserTDPtr != NULL) {                               /* Yes, extended transfer parameters? */
      UserTDPtr->TransferState = LDD_USB_TRANSFER_DONE;    /* Update transfer state */
      if (UserTDPtr->CallbackFnPtr != NULL) {              /* Notification required? */
        UserTDPtr->CallbackFnPtr(DevDataPtr->UserDeviceDataPtr, UserTDPtr); /* Call notification function */
      }
    }
    if (TDPtr->Active == FALSE) {                          /* TD reused in Callback? */
      TDPtr = TDPtr->pNextTD;                              /* No, get next Transfer descriptor */
      EpDataPtr->pCurrentTD = TDPtr;
      if (TDPtr->Active == TRUE) {                         /* Next transfer ready? */
        USB_LDD_DeviceQueueDataPacket(EpDataPtr,TDPtr);    /* Queue next packet */
      }
    }
  } else {
    USB_LDD_DeviceQueueDataPacket(EpDataPtr,TDPtr);        /* Queue next packet */
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceAbortAllTransfers (component USB_LDD)
**
**     Description :
**         Cancels all pending transfers for given endpoint
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError USB_LDD_DeviceAbortAllTransfers(LDD_TDeviceData *DeviceDataPtr, USB_LDD_TEpData *EpDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TTD                     *TDPtr;
  LDD_USB_Device_TTD              *UserTDPtr;
  uint32_t                         CtrlRegVal;

  if (EpDataPtr->EpState >USB_LDD_EP_NOT_CONFIGURED) {
    BDPtr    = (USB_LDD_TBD*)((uint32_t)EpDataPtr->BDPtr & ~(uint32_t)0x08U);
    /* Flush BD */
    /* Compute DATA0/DATA1 for next transaction */
    CtrlRegVal = BDPtr->CtrlReg;
    BDPtr->CtrlReg = 0x00U;
    BDPtr++;
    CtrlRegVal ^= BDPtr->CtrlReg;
    BDPtr->CtrlReg = 0x00U;
    if ((CtrlRegVal & USB_LDD_BD_LE_OWM) != 0x00U) {
      EpDataPtr->BDPtr = (USB_LDD_TBD *)((uint32_t)(EpDataPtr->BDPtr) ^ 0x08U);
    }
    /* Update transfer status and call user provided callback */
    TDPtr = EpDataPtr->pCurrentTD;
    do {                                                   /* For each transfer descriptor do: */
      if (TDPtr->Active) {                                 /* Active transfer descriptor? */
        UserTDPtr = TDPtr->UserTDPtr;                      /* Yes, remember extended transfer parameters address */
        if (UserTDPtr != NULL) {                           /* Extended transfer parameters? */
          UserTDPtr->TransferState = LDD_USB_TRANSFER_ERROR_CANCELLED; /* Yes, update transfer status */
          if (UserTDPtr->CallbackFnPtr != NULL) {          /* Callback required? */
            UserTDPtr->CallbackFnPtr(DevDataPtr->UserDeviceDataPtr, UserTDPtr); /* Call notification function */
          }
        }
        TDPtr->Active = FALSE;                             /* Transfer is finished */
      }
      TDPtr = TDPtr->pNextTD;                              /* Get next TD */
    } while (TDPtr != EpDataPtr->pCurrentTD);
    EpDataPtr->EpState = USB_LDD_EP_IDLE;
    return ERR_OK;
  } else {
    return ERR_FAILED;
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceDisableAllEp (component USB_LDD)
**
**     Description :
**         Initializes internal data structure and disables all endpoints.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceDisableAllEp(USB_LDD_TDeviceData *DevDataPtr)
{
  uint32_t                         x;
  USB_LDD_TBD                     *BDPtr = (USB_LDD_TBD*)(void*)DevDataPtr;
  volatile uint8_t                *EpCtrlRegPtr = USB_PDD_GetEpCtrlRegAddr(USB0_BASE_PTR, 0x00);

  for (x = 0x00U; x <= MAX_BD_IDX; x++) {                  /* Clear BDT */
    BDPtr->CtrlReg = 0x00U;
    BDPtr++;
  }
  for (x = 0x00U; x <= 0x0FU; x++) {                       /* Clear all "endpoint control" registers */
    *EpCtrlRegPtr = (uint8_t)0x00U;
    EpCtrlRegPtr++;
  }
  for (x = 0x00U; x <= MAX_EP_IDX; x++) {                  /* Discard all pending transfers */
    (void)USB_LDD_DeviceAbortAllTransfers(DevDataPtr, &DevDataPtr->EpData[x]);
  }

  /* Sets endpoint data variables to the initialization values */
  DevDataPtr->EpData[0x00u].EpState      = USB_LDD_EP_NOT_CONFIGURED;
  DevDataPtr->EpData[0x00u].EpNumber     = 0x00U;
  DevDataPtr->EpData[0x00u].TDQueuePtr   = &DevDataPtr->EP_0_OUT_dTD_Queue[0];
  DevDataPtr->EpData[0x00u].EpCtrlRegPtr = USB_PDD_GetEpCtrlRegAddr(USB0_BASE_PTR, 0x00U);
  DevDataPtr->EpData[0x00u].BDPtr        = &DevDataPtr->BDT[0x00U];
  DevDataPtr->EpData[0x00u].SDPPtr       = (LDD_USB_TSDP *)(void *)(DevDataPtr->EP_0_Control_PacketBuffer);
  DevDataPtr->EpData[0x01u].EpState      = USB_LDD_EP_NOT_CONFIGURED;
  DevDataPtr->EpData[0x01u].EpNumber     = 0x00U;
  DevDataPtr->EpData[0x01u].TDQueuePtr   = &DevDataPtr->EP_0_IN_dTD_Queue[0];
  DevDataPtr->EpData[0x01u].EpCtrlRegPtr = USB_PDD_GetEpCtrlRegAddr(USB0_BASE_PTR, 0x00);
  DevDataPtr->EpData[0x01u].BDPtr        = &DevDataPtr->BDT[0x02u];
  DevDataPtr->EpData[0x01u].SDPPtr       = (LDD_USB_TSDP *)(void *)(DevDataPtr->EP_0_Control_PacketBuffer);
  DevDataPtr->EpData[0x02u].TransferType = LDD_USB_BULK;
  DevDataPtr->EpData[0x03u].EpState      = USB_LDD_EP_NOT_CONFIGURED;
  DevDataPtr->EpData[0x03u].EpNumber     = 0x01U;
  DevDataPtr->EpData[0x03u].TDQueuePtr   = &DevDataPtr->EP_1_IN_dTD_Queue[0];
  DevDataPtr->EpData[0x03u].EpCtrlRegPtr = USB_PDD_GetEpCtrlRegAddr(USB0_BASE_PTR, 0x01);
  DevDataPtr->EpData[0x03u].BDPtr        = &DevDataPtr->BDT[0x06u];
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceHandleEndpointUsbStatus (component USB_LDD)
**
**     Description :
**         See description of the GetUsbStatus() and SetUsbStatus() 
**         method.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError USB_LDD_DeviceHandleEndpointUsbStatus(USB_LDD_TDeviceData *DevDataPtr, uint16_t Id, uint16_t *CmdStatusPtr)
{
  USB_LDD_TEpData                 *EpDataPtr;
  uint8_t                          EpNum = (uint8_t)(Id & (uint32_t)0x0FU);
  uint8_t                          EpDir = (uint8_t)(Id & (uint32_t)0x80U);
  LDD_TError                       Res = ERR_OK;

  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    return Res;
  }
  if ((Id & ~(uint32_t)LDD_USB_ID_EP_MASK) == 0x00U) {     /* EP address valid? */
    EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx data structure */
    if (EpDataPtr->TransferType != LDD_USB_CONTROL) {      /* Control EP? */
      if (EpDir != LDD_USB_DIR_OUT) {                      /* No, update EpDataPtr for IN direction endpoint */
        EpDataPtr++;
      }
    }
    if ((uint32_t)EpDataPtr > (uint32_t)&(DevDataPtr->EpData[MAX_EP_IDX + 0x01u])) { /* Check address of EPx data structure */
      Res = ERR_PARAM_ADDRESS;
    }
    if (EpDataPtr->EpState <= USB_LDD_EP_NOT_CONFIGURED) { /* Is EP configured? */
      Res = ERR_PARAM_ADDRESS;                             /* No, =invalid EP */
    }
    if (EpDataPtr->TransferType == LDD_USB_ISOCHRONOUS) {  /* Isochronous EP? */
      Res = ERR_FAILED;                                    /* Isochronous EP has no HALT feature */
    }
    if (Res == ERR_OK) {
      switch (*CmdStatusPtr) {
        case LDD_USB_CMD_CLR_EP_HALT_FATURE:
          USB_LDD_DeviceUnstallEndpoint((LDD_TDeviceData*)DevDataPtr, EpNum, EpDir);
          break;
        case LDD_USB_CMD_SET_EP_HALT_FATURE:
          USB_LDD_DeviceStallEndpoint((LDD_TDeviceData*)DevDataPtr, EpNum, EpDir);
          break;
        case LDD_USB_CMD_GET_EP_STATUS:
          if (((uint32_t)EpDataPtr->EpState & (uint32_t)USB_LDD_EP_STALLED) != 0x00U) { /* Is EP stalled? */
            *CmdStatusPtr = LDD_USB_CMD_EP_STATUS_HALT_MASK; /* Yes, set halt feature in the returned value */
          } else {
            *CmdStatusPtr = 0x00U;                         /* Yes, clear halt feature in the returned value */
          }
          break;
        default:
          Res =  ERR_PARAM_COMMAND;                        /* Unsupported command */
          break;
      }
    }
  } else {
    Res = ERR_PARAM_ADDRESS;                               /* Bad EP address */
  }
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_Init (component USB_LDD)
*/
/*!
**     @brief
**         Initializes USB device. Allocates memory for the device data
**         structure, interrupts, pins, etc. This method doesn't enable
**         device pull-up. Use Enable() method to enable device pull-up.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Pointer to the dynamically allocated private
**                           structure or NULL if there was an error.
*/
/* ===================================================================*/
LDD_TDeviceData * USB_LDD_Init(LDD_TUserData *UserDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr;

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DevDataPtr = &DevDataPtr__DEFAULT_RTOS_ALLOC;
  /* {Default RTOS Adapter} Driver memory allocation: Fill the allocated memory by zero value */
  PE_FillMemory(DevDataPtr, 0U, sizeof(USB_LDD_TDeviceData));
  DevDataPtr->UserDeviceDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_USB0__DEFAULT_RTOS_ISRPARAM =  DevDataPtr;
  /* Interrupt vector(s) priority setting */
  /* NVIC_IPR6: PRI_24=0x80 */
  NVIC_IPR6 = (uint32_t)((NVIC_IPR6 & (uint32_t)~(uint32_t)(
               NVIC_IP_PRI_24(0x7F)
              )) | (uint32_t)(
               NVIC_IP_PRI_24(0x80)
              ));                                  
  /* NVIC_ISER: SETENA|=0x01000000 */
  NVIC_ISER |= NVIC_ISER_SETENA(0x01000000);                                   
  /* Clock setting */
  /* Input clock source:      Auto select */
  /* Input clock frequency:   48 MHz */
  /* Module clock frequency:  48 MHz */
  /* SIM_SOPT2: USBSRC=1 */
  SIM_SOPT2 |= SIM_SOPT2_USBSRC_MASK;  /* Divided PllFll clock */
  /* Enable module clock */
  /* SIM_SCGC4: USBOTG=1 */
  SIM_SCGC4 |= SIM_SCGC4_USBOTG_MASK;                                   
  /* Reset module */
  /* USB0_USBTRC0: USBRESET=1 */
  USB0_USBTRC0 = USB_USBTRC0_USBRESET_MASK; /* Reset module */
  while (USB_PDD_GetModuleResetPendingFlag(USB0_BASE_PTR)) {
    ; /* Wait for reset done */
  }
  /* Enable USB voltage regulator */
  /* SIM_SOPT1: ??=1 */
  SIM_SOPT1 |= 0x80U;                  /* Enable USB voltage regulator */
  /* USB0_USBTRC0: ??=1 */
  USB0_USBTRC0 = 0x40U;                /* Enable internal pull-up */
  /* USB0_USBCTRL: SUSP=1,PDE=0 */
  USB0_USBCTRL = USB_USBCTRL_SUSP_MASK; /* Enable weak pull-downs and suspend transceiver */
  /* USB0_OTGCTL: DPHIGH=0,??=0,DPLOW=0,DMLOW=0,??=0,OTGEN=1,??=0,??=0 */
  USB0_OTGCTL = USB_OTGCTL_OTGEN_MASK;                                   
  /* Set BDT address */
  USB0_BDTPAGE1 = (uint8_t)((((uint32_t)DevDataPtr) >> 8) & 0xFEU);
  USB0_BDTPAGE2 = (uint8_t)((((uint32_t)DevDataPtr) >> 16) & 0xFFU);
  USB0_BDTPAGE3 = (uint8_t)((((uint32_t)DevDataPtr) >> 24) & 0xFFU);
  /* Initialize device data structure */
  DevDataPtr->DeviceState = LDD_USB_DEVICE_DISABLED;
  DevDataPtr->msCounter = -1;                               /* No timing request */
  DevDataPtr->EnUser = FALSE;
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_USB_LDD_ID,DevDataPtr);
  return (LDD_TDeviceData*)(DevDataPtr);                    /* Return pointer to the data data structure */
}

/*
** ===================================================================
**     Method      :  USB_LDD_Deinit (component USB_LDD)
*/
/*!
**     @brief
**         Disables and deinitializes the device and frees the device
**         data structure memory.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
*/
/* ===================================================================*/
void USB_LDD_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  (void)DevDataPtr;                                        /* Parameter is not used, suppress unused argument warning */
  /* {Default RTOS Adapter} Critical section begin, general PE function is used */
  EnterCritical();
  /* Reset module */
  USB_PDD_ResetModule(USB0_BASE_PTR);
  while (USB_PDD_GetModuleResetPendingFlag(USB0_BASE_PTR)) {
    ; /* Wait for reset done */
  }
  /* Disable module clock */
  /* SIM_SCGC4: USBOTG=0 */
  SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_USBOTG_MASK);                                   
  /* {Default RTOS Adapter} Critical section end, general PE function is used */
  ExitCritical();
  /* Restoring the interrupt vector */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* Unregistration of the device structure */
  PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_USB_LDD_ID);
  /* Deallocation of the device structure */
  /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallocation code is generated */
}

/*
** ===================================================================
**     Method      :  USB_LDD_Enable (component USB_LDD)
*/
/*!
**     @brief
**         Enables the USB device (PHY, SIE). Enables device's DP(DM)
**         pull-up.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - 
*/
/* ===================================================================*/
LDD_TError USB_LDD_Enable(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  if (!DevDataPtr->EnUser) {
    DevDataPtr->EnUser = TRUE;
    USB_LDD_UsbLock(DevDataPtr);
    DevDataPtr->DeviceState = LDD_USB_DEVICE_VBUS_ON;      /* Remember new device state */
    DevDataPtr->msCounter = -1;                            /* No timing request */
    USB_LDD_DeviceDisableAllEp(DevDataPtr);
    USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE); /* Enable transceiver */
    USB_PDD_ClearOtgInterruptFlags(USB0_BASE_PTR, USB_PDD_1_MSEC_INT); /* Clear 1ms interrupt flag */
    USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear all error interrupt flags */
    USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear all usb interrupt flags */
    USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_SLEEP_INT | USB_PDD_USB_RST_INT); /* Enable reset and suspend interrupts */
    USB_PDD_Enable1msInterrupt(USB0_BASE_PTR);             /* Enable "1ms" interrupt */
    USB_PDD_EnableDevice(USB0_BASE_PTR, PDD_ENABLE);        /* Enable device mode */
    DevDataPtr->DeviceState = LDD_USB_DEVICE_VBUS_ON;       /* VBUS is on, remember new state */
    USB_PDD_WriteOtgControlReg(USB0_BASE_PTR, (USB_PDD_ReadOtgControlReg(USB0_BASE_PTR) | (uint8_t)0x80)); /* Enable D+ pull-up.*/
    USB_LDD_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_Disable (component USB_LDD)
*/
/*!
**     @brief
**         Disabled device's DP(DM) pull-up. Disables PHY, etc.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - 
*/
/* ===================================================================*/
LDD_TError USB_LDD_Disable(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  if (DevDataPtr->EnUser) {
    DevDataPtr->EnUser = FALSE;
    USB_LDD_UsbLock(DevDataPtr);
    DevDataPtr->DeviceState = LDD_USB_DEVICE_DISABLED;     /* Remember new device state */
    DevDataPtr->msCounter = -1;                            /* No timing request */
    USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);            /* Disable "1ms" interrupt */
    USB_PDD_SetErrorInterruptMask(USB0_BASE_PTR, 0x00U);   /* Disable all error interrupt */
    USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, 0x00U);     /* Disable all usb interrupt */
    USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_ENABLE); /* Disable transceiver */
    USB_PDD_WriteOtgControlReg(USB0_BASE_PTR, (USB_PDD_ReadOtgControlReg(USB0_BASE_PTR) & (uint8_t)~(uint8_t)0x80)); /* Disable D+ pull-up */
    USB_PDD_DisableModule(USB0_BASE_PTR);
    USB_LDD_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceGetUsbStatus (component USB_LDD)
*/
/*!
**     @brief
**         Returns the status of the object (e.g. endpoint). This
**         method is intended to be used in the standard USB
**         'GetStatus' request handler.
**         The object is described by the command (CmdStatusPtr
**         parameter) and by the id (Id parameter). 
**         The supported commands are:
**         [1) LDD_USB_CMD_GET_EP_STATUS] - Fills the memory addressed
**         by the CmdStatusPtr parameter by the current endpoint XXX
**         status (where XXX = Id parameter value) .
**         Format of the returned status is defined in the USB
**         specification 2.0, figure 9.6.
**         The LDD_USB_CMD_EP_STATUS_HALT_MASK constant can be used to
**         get endpoint status from the returned value.
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         Id              - Id. (E.g endpoint address for endpoint
**                           status, ...)
**                           The Id parameter value has the same format
**                           as wIndex parameter in the setup data
**                           packet - see USB specification.
**     @param
**         CmdStatusPtr    - Pointer to the uint16_t
**                           in/out variable. This variable must
**                           contains requested command before the
**                           method is called and contains requested
**                           status after the method returns.
**                           The supported command are:
**                           LDD_USB_CMD_GET_EP_STATUS
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
**                           ERR_PARAM_ADDRESS - No such object (e.g.
**                           endpoint doesn't exists or is not enabled
**                           by the host). Note: The 'Id' parameter
**                           check is always enabled in order to
**                           simplify implementation of the standard USB
**                           GetStatus request handler.
**                           ERR_FAILED - Command not supported for
**                           current object setting (e.g. STALL feature
**                           is not supported for isochronous endpoints).
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - The command cannot be accomplished
**                           in XXX <device state>.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceGetUsbStatus(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t *CmdStatusPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData *)DeviceDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (*CmdStatusPtr == LDD_USB_CMD_GET_EP_STATUS) {         /* EP command? */
    Res = USB_LDD_DeviceHandleEndpointUsbStatus(DevDataPtr, Id, CmdStatusPtr);
  } else {
    Res = ERR_PARAM_COMMAND;
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceSetUsbStatus (component USB_LDD)
*/
/*!
**     @brief
**         Sets the status(feature) of the object (e.g. endpoint). This
**         method is intended to be used in the standard USB
**         ClearFeature/SetFeature request handler.
**         The object is described by the command (Cmd parameter) and
**         by the id (Id parameter). 
**         The supported commands are:
**         [LDD_USB_CMD_SET_EP_HALT_FATURE] - Sets HALT feature for
**         endpoint XXX (where XXX = Id parameter value).
**         [LDD_USB_CMD_CLR_EP_HALT_FATURE] - Clears HALT feature for
**         endpoint XXX (where XXX = Id parameter value).
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         Id              - Id. (E.g endpoint address for endpoint
**                           status, ...)
**                           The Id parameter value has the same format
**                           as wIndex parameter in the setup data
**                           packet - see USB specification.
**     @param
**         Cmd             - Command. Supported commands are:
**                           LDD_USB_CMD_SET_EP_HALT_FATURE
**                           LDD_USB_CMD_CLR_EP_HALT_FATURE
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
**                           ERR_PARAM_ADDRESS - No such object (e.g.
**                           endpoint doesn't exists or is not enabled
**                           by the host). Note: The 'Id' parameter
**                           check is always enabled in order to
**                           simplify implementation of the standard USB
**                           GetStatus request handler.
**                           ERR_FAILED - Command not supported for
**                           current object setting (e.g. STALL feature
**                           is not supported for isochronous endpoints).
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - The command cannot be accomplished
**                           in XXX <device state>.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceSetUsbStatus(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t Cmd)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData *)DeviceDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  switch (Cmd) {
    case LDD_USB_CMD_CLR_EP_HALT_FATURE:
    case LDD_USB_CMD_SET_EP_HALT_FATURE:
       Res = USB_LDD_DeviceHandleEndpointUsbStatus(DevDataPtr, Id, &Cmd);
       break;
    default:
      Res = ERR_PARAM_COMMAND;
      break;
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceSetAddress (component USB_LDD)
*/
/*!
**     @brief
**         Sets new device address. Address must be in range 0-127 but
**         no check is performed.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         Address         - New device address.
*/
/* ===================================================================*/
void USB_LDD_DeviceSetAddress(LDD_TDeviceData *DeviceDataPtr, uint8_t Address)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  USB_LDD_UsbLock(DevDataPtr);
  USB_PDD_WriteAddressReg(USB0_BASE_PTR, Address);
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceAssertResume (component USB_LDD)
*/
/*!
**     @brief
**         Starts Remote wake-up signaling. Remote wake up signaling is
**         stopped automatically (by the HW or explicitly by the SW).
**         [Note:] Resume signaling can be started only if device is in
**         suspend state more then 5 ms (Device state =
**         LDD_USB_DEVICE_SUSPENDED_RESUME_READY).
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - The command is not supported in
**                           XXX <device state>.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceAssertResume(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_SUSPENDED_RESUME_READY) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_ENABLE);
  USB_LDD_StartTimer(DevDataPtr, 0x06); /* Force resume signaling for at least 5 ms */
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceInitEndpoint (component USB_LDD)
*/
/*!
**     @brief
**         Initializes endpoint according to the values in the
**         <standard Endpoint descriptor> and in the flags parameter.
**         As soon as the ERR_OK is returned the endpoint can be used
**         to transmit data. To initialize endpoint 0 you can create
**         Endpoint descriptor for EP0 or you can use the <standard
**         Device descriptor>.
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpDescriptorPtr - Pointer to
**                           standard Endpoint descriptor structure
**                           pointer. To initialize EP0 you can use
**                           pointer to the standard Device descriptor
**                           structure.
**     @param
**         Flags           - Additional EP properties. 
**                           For Bulk/Interrupt transfer types:
**                           0 = no ZLT,  1 = ZLT
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the HW.
**                           ERR_PARAM_TYPE - Requested transfer is not
**                           supported by the HW for given address and
**                           direction.
**                           ERR_PARAM_SIZE - Requested max. packet size
**                           is not supported by the HW.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - Device is not in enabled <state>.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceInitEndpoint(LDD_TDeviceData *DeviceDataPtr, LDD_USB_TEpDescriptor *EpDescriptorPtr, uint8_t Flags)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  bool                             ZLT;
  uint32_t                         x,y,EpNum;
  uint32_t                         QueueSize;
  uint32_t                         EpDir;
  LDD_USB_TTransferType            EpTransferType;
  uint16_t                         EpMaxPacketSize;
  USB_LDD_TTD                     *TDPtr;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res = ERR_OK;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  if (EpDescriptorPtr->bDescriptorType == LDD_USB_DT_DEVICE) {
    EpNum           = 0U;
    EpDataPtr       = DevDataPtr->EpData; /* Get address of EPx OUT data structure */
    EpTransferType  = LDD_USB_CONTROL;
    EpMaxPacketSize = ((LDD_USB_TDevDescriptor *)(void *)EpDescriptorPtr)->bMaxPacketSize0;
  } else {
    EpNum           = ((uint32_t)EpDescriptorPtr->bEndpointAddress & 0x7FU);
    EpDataPtr       = &DevDataPtr->EpData[(uint8_t)((EpDescriptorPtr->bEndpointAddress & 0x7FU) << 0x01U)]; /* Get address of EPx OUT data structure */
    EpTransferType  = (LDD_USB_TTransferType )((EpDescriptorPtr->bmAttributes) & 0x03U);
    EpMaxPacketSize = (uint16_t)((uint16_t)(*(((uint8_t*)(void*)&EpDescriptorPtr->wMaxPacketSize) + 0x01U)) << 0x08);
    EpMaxPacketSize += *(uint8_t*)(void*)&EpDescriptorPtr->wMaxPacketSize;
  }
  if (EpTransferType == LDD_USB_CONTROL) { /* Control EP has queue size = 0 */
    QueueSize = 0x00U;
    EpDir     = LDD_USB_DIR_OUT;
    y         = 0x01U;
    ZLT       = TRUE;
  } else {
    QueueSize = (uint32_t)Flags & 0x7FU;
    ZLT       = (bool)(Flags & 0x80U);
    EpDir     = ((uint32_t)(EpDescriptorPtr->bEndpointAddress) & 0x80U);
    y         = 0x00U;
  }
  if (QueueSize == 0x00U) {
    QueueSize++;
  }
  do {
    if (EpDir != LDD_USB_DIR_OUT) {    /* EPx IN data structure is the next item */
      EpDataPtr++;
    }
    if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX]) { /* Check address of EPx data structure */
      Res = ERR_PARAM_ADDRESS;
    }
    if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
      Res = ERR_PARAM_ADDRESS;
    }
    if (Res != ERR_OK) {
      break;
    }
    TDPtr                       = EpDataPtr->TDQueuePtr;
    EpDataPtr->EpState          = USB_LDD_EP_IDLE;
    EpDataPtr->TransferType     = EpTransferType;
    EpDataPtr->MaxPacketSize    = EpMaxPacketSize;
    EpDataPtr->ZLT              = ZLT;
    EpDataPtr->pCurrentTD       = TDPtr;
    EpDataPtr->pLastTD          = TDPtr;
    EpDataPtr->BDCtrlRegVal     = USB_LDD_BD_DATA0 | USB_LDD_BD_OWM | USB_LDD_BD_DTS;
    /* Prepare TDs queue */
    for (x = 0x00U; x < QueueSize; x++) {
      TDPtr->Active = FALSE;
      TDPtr->pNextTD = (TDPtr + 0x01U); /* Join TDs */
      TDPtr++;
    }
    (--TDPtr)->pNextTD = EpDataPtr->TDQueuePtr;
    BDPtr = EpDataPtr->BDPtr;
    BDPtr->CtrlReg = 0x00U;
    (BDPtr + 0x01U)->CtrlReg = 0x00U;
    if (EpTransferType == LDD_USB_CONTROL) {
      if (EpDir == LDD_USB_DIR_IN) {   /* EPx IN data structure is the next item */
        USB_PDD_EnableControlEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      } else {
        EpDir = LDD_USB_DIR_IN;
      }
    } else if (EpTransferType == LDD_USB_ISOCHRONOUS) {
      if (EpDir == LDD_USB_DIR_IN) { /* IN(Tx) direction */
        USB_PDD_EnableIsoTxEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      } else {  /* OUT(Rx) direction */
        USB_PDD_EnableIsoRxEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      }
    } else {
      if (EpDir == LDD_USB_DIR_IN) { /* IN(Tx) direction? */
        USB_PDD_EnableBulkOrIntTxEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      } else { /* OUT(Rx) direction */
        USB_PDD_EnableBulkOrIntRxEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      }
    }
  } while (y--);
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceDeinitEndpoint (component USB_LDD)
*/
/*!
**     @brief
**         Deinitializes EP and disables it in the HW. For control EP
**         both directions are deinitialized. All pending transfers are
**         aborted and callback functions are called, if enabled.
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the HW.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - Device is not in enabled <state>.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceDeinitEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx OUT data structure */
  if (EpDir != LDD_USB_DIR_OUT) {                          /* EPx IN is next item in the array */
    EpDataPtr++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX + 0x01u]) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  if (EpDataPtr->EpState > USB_LDD_EP_NOT_CONFIGURED) {
    if (EpDataPtr->TransferType == LDD_USB_CONTROL) {       /* Control EP? */
      USB_PDD_EnableControlEP(USB0_BASE_PTR, EpNum, PDD_DISABLE);
      (EpDataPtr + 1)->EpState = USB_LDD_EP_NOT_CONFIGURED;
    } else {
      if (EpDir == LDD_USB_DIR_OUT) {                       /* OUT(Rx) direction */
        USB_PDD_DisableTxEP(USB0_BASE_PTR, EpNum);
      } else {
        USB_PDD_DisableRxEP(USB0_BASE_PTR, EpNum);
      }
    }
    EpDataPtr->EpState = USB_LDD_EP_NOT_CONFIGURED;
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceStallEndpoint (component USB_LDD)
*/
/*!
**     @brief
**         Sets STALL feature for endpoint.
**         Note: No parameters and endpoint state are checked. The
**         <DeviceSetUsbStatus()> method provides same functionality
**         with state and parameter checking.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
*/
/* ===================================================================*/
void USB_LDD_DeviceStallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  USB_LDD_TBD                     *BDPtr;

  USB_LDD_UsbLock(DevDataPtr);
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx data structure */
  if (EpDataPtr->TransferType == LDD_USB_CONTROL) {        /* Control EP? */
    USB_PDD_StallControlEP(USB0_BASE_PTR, EpNum, PDD_ENABLE); /* Stall EP */
    (EpDataPtr + 1)->EpState = (USB_LDD_TePState)((uint32_t)((EpDataPtr + 1)->EpState) | (uint32)USB_LDD_EP_STALLED);
    USB_LDD_DeviceReceiveSetupPacket(EpDataPtr);           /* Be ready to receive setup data packet */
  } else {
    if (EpDir != LDD_USB_DIR_OUT) {
      EpDataPtr++;
    }
    BDPtr = EpDataPtr->BDPtr;
    BDPtr->CtrlReg |= USB_LDD_BD_LE_STALL;                 /* UNSTALL ODD BD entry */
    (++BDPtr)->CtrlReg |= USB_LDD_BD_LE_STALL;             /* UNSTALL ODD BD entry */
  }
  EpDataPtr->EpState = (USB_LDD_TePState)((uint32_t)(EpDataPtr->EpState) | (uint32)USB_LDD_EP_STALLED);
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceUnstallEndpoint (component USB_LDD)
*/
/*!
**     @brief
**         Clears STALL feature for endpoint.
**         Note: No parameters and endpoint state are checked. The
**         <DeviceSetUsbStatus()> method provides same functionality
**         with state and parameter checking.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
*/
/* ===================================================================*/
void USB_LDD_DeviceUnstallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  USB_LDD_TBD                     *BDPtr;

  USB_LDD_UsbLock(DevDataPtr);
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx data structure */
  if (EpDataPtr->TransferType == LDD_USB_CONTROL) {         /* Control EP? */
    (EpDataPtr + 1)->EpState = (USB_LDD_TePState)((uint32_t)((EpDataPtr +1 )->EpState) & ~(uint32)USB_LDD_EP_STALLED);
  } else {
    if (EpDir != LDD_USB_DIR_OUT) {
      EpDataPtr++;
    }
    BDPtr = EpDataPtr->BDPtr;
    BDPtr->CtrlReg &= ~(USB_LDD_BD_LE_STALL | USB_LDD_BD_LE_DATA1); /* UNSTALL ODD BD entry, set data toggle to DATA0 */
    (++BDPtr)->CtrlReg &= ~(USB_LDD_BD_LE_STALL | USB_LDD_BD_LE_DATA1); /* UNSTALL EVEN BD entry, set data toggle to DATA0 */
  }
  EpDataPtr->EpState = (USB_LDD_TePState)((uint32_t)(EpDataPtr->EpState) & ~(uint32)USB_LDD_EP_STALLED);
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceReadSetupData (component USB_LDD)
*/
/*!
**     @brief
**         Fills the given buffer with last received setup data packet
**         for given EP.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         SDPPtr          - Address of the buffer for setup data.
*/
/* ===================================================================*/
void USB_LDD_DeviceReadSetupData(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, LDD_USB_TSDP *SDPPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TEpData                 *RxEpDataPtr;
  USB_LDD_TEpData                 *TxEpDataPtr;

  USB_LDD_UsbLock(DevDataPtr);
  RxEpDataPtr = &DevDataPtr->EpData[(uint32_t)EpNum << 0x01u]; /* Get address of EPx OUT data structure */
  TxEpDataPtr = RxEpDataPtr + 0x01U;                       /* Get address of EPx IN data structure */
  BDPtr       = RxEpDataPtr->LastTrBDPtr;
  *SDPPtr = *(LDD_USB_TSDP*)BDPtr->BufferPtr;
  USB_PDD_ClearTxSuspendFlag(USB0_BASE_PTR);               /* Restore packet transmission */
  TxEpDataPtr->TT.Ctrl.ReqDataSize = SDPPtr->wLength;      /* Remember requested data size */
  RxEpDataPtr->TT.Ctrl.ReqDataSize = SDPPtr->wLength;      /* Remember requested data size */
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceSendData (component USB_LDD)
*/
/*!
**     @brief
**         This method prepares data to be sent to the HOST (transfer
**         request). The transfer request is queued into the internal
**         queue of requests for given endpoint. Some devices have HW
**         queues. On other devices the queue can be emulated by the SW
**         or no queue is implemented (property Max. queue size = 1 and
**         cannot be modified). Size of queue can be defined for each
**         endpoint at the design time. As soon as the host sends IN
**         token data from the request on the queue head are sent to
**         the HOST. This process is repeated until all data are
**         transferred or transfer is cancelled. If the transfer is
**         done the request is removed from the queue and next request
**         becomes ready for transmission, if queue not empty.
**         Each transfer is described by the <transfer descriptor (TD)>
**         structure.
**         The first item of the TD is the <Head> structure. The Head
**         structure item is required and contains these items:
**         _/[EpNum]/_ - endpoint number.
**         _/[BufferPtr]/_ - buffer address.
**         _/[BufferSize]/_ - buffer size.
**         _/[Flags]/_ - flags:
**         _/LDD_USB_DEVICE_TRANSFER_FLAG_ZLT/_ - this flag can be used
**         to force zero-length termination(ZLT) of the transfer.
**         _/LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM/_ - see below.
**         The following items of the TD are optional:
**         _/[TransmittedDataSize]/_ - this item is set by the driver
**         and contains actual number of transmitted data.
**         _/[CallbackFnPtr]/_ - pointer to the callback function
**         called (if not NULL) after the transfer is done.
**         _/[ParamPtr]/_ - parameter passed to the callback function.
**         The optional items can be used to track the status of the
**         transfer request and are used(accessed) by the driver only
**         if <LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM> flag is set to
**         '1' in the Head.Flags item. In this case the TD must be
**         accessible from the ISR and may be freed only if the
**         transfer is done (TransfereState item must be lower then
**         LDD_USB_TRANSFER_QUEUED). Pending transfer requests can be
**         cancelled by the <DeviceCancelTransfer()> method.
**         Transfer is done if all data are sent. If data size = max.
**         packet size and ZLT is enabled the zero length packet is
**         send as the last packet of the transfer.
**         [Note:]For control transfer the transmitted data size
**         truncated (if necessary) by the driver to the size requested
**         by the host (wLength item of setup data packet) and the ZLT
**         is added if needed. Note: On some MCUs (e.g. Kinetis) must
**         be the address of the data buffer 4 bytes aligned.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         TransferDescriptorPtr -
**                           Pointer to the <transfer descriptor (TD)>
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
**                           ERR_NOTAVAIL - Endpoint is not <initialized>.
**                           ERR_FAILED - Endpoint is STALLed.
**                           ERR_QFULL - Endpoint transfer queue is full.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceSendData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr)
{
  return(USB_LDD_DeviceQueueTransfer((USB_LDD_TDeviceData*)DeviceDataPtr, TransferDescriptorPtr, LDD_USB_DIR_IN));
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceRecvData (component USB_LDD)
*/
/*!
**     @brief
**         This method prepares buffer for data sent by the HOST
**         (transfer request). The transfer request is queued into the
**         internal queue of requests for given endpoint. Some devices
**         have HW queues. On other devices the queue can be emulated
**         by the SW or no queue is implemented (property Max. queue
**         size = 1 and cannot be modified). Size of queue can be
**         defined for each endpoint at the design time. Data from the
**         HOST are stored into the provided buffer. If the transfer is
**         done the request is removed from the queue and next request
**         becomes ready for transmission, if queue not empty.
**         Each transfer is described by the <transfer descriptor (TD)>
**         structure.
**         The first item of the TD is the <Head> structure. The Head
**         structure item is required and contains these items:
**         _/[EpNum]/_ - endpoint number.
**         _/[BufferPtr]/_ - buffer address.
**         _/[BufferSize]/_ - buffer size.
**         _/[Flags]/_ - flags:
**         _/LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM/_ - see below.
**         The following items of the TD are optional:
**         _/[TransmittedDataSize]/_ - this item is set by the driver
**         and contains actual number of transmitted data.
**         _/[CallbackFnPtr]/_ - pointer to the callback function
**         called (if not NULL) after the transfer is done.
**         _/[ParamPtr]/_ - parameter passed to the callback function.
**         The optional items can be used to track the status of the
**         transfer request and are used(accessed) by the driver only
**         if <LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM> flag is set to
**         '1' in the Head.Flags item. In this case the TD must be
**         accessible from the ISR and may be freed only if the
**         transfer is done (TransfereState item must be lower then
**         LDD_USB_TRANSFER_QUEUED). Pending transfer requests can be
**         cancelled by the <DeviceCancelTransfer()> method.
**         Transfer is done if all requested data are received or
**         short(zero length) packet is received. Note: On some MCUs (e.
**         g. Kinetis) must be the address of the data buffer 4 bytes
**         aligned.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         TransferDescriptorPtr -
**                           Pointer to the <transfer descriptor (TD)>
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
**                           ERR_NOTAVAIL - Endpoint is not <initialized>.
**                           ERR_FAILED - Endpoint is STALLed.
**                           ERR_QFULL - Endpoint transfer queue is full.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceRecvData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr)
{
  return(USB_LDD_DeviceQueueTransfer((USB_LDD_TDeviceData*)DeviceDataPtr, TransferDescriptorPtr, LDD_USB_DIR_OUT));
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceGetTransferStatus (component USB_LDD)
*/
/*!
**     @brief
**         This method returns current status of the endpoint. If
**         endpoint is idle/busy/stalled, the
**         ERR_IDLE/ERR_BUSY/ERR_FAILED is return. Please note that
**         these error codes reports endpoint status, not error of the
**         method.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
**                           ERR_NOTAVAIL - Endpoint is not <initialized>.
**                           ERR_FAILED - Endpoint is STALLed.
**                           ERR_BUSY - Endpoint transfer is
**                           transmitting data.
**                           ERR_IDLE - Endpoint is idle.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceGetTransferStatus(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx OUT data structure */
  if (EpDir != LDD_USB_DIR_OUT) {                          /* EPx IN is next item in the array */
    EpDataPtr++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX + 0x01u]) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  if (EpDataPtr->EpState >= USB_LDD_EP_IDLE) {
    if (EpDataPtr->pCurrentTD->Active) {
      Res = ERR_BUSY;                                      /* Endpoint is busy */
    } else {
      Res = ERR_IDLE;                                      /* Endpoint is idle */
    }
  } else if ((uint32_t)EpDataPtr->EpState & (uint32_t)USB_LDD_EP_STALLED) {
    Res = ERR_FAILED;                                      /* Endpoint is stalled */
  } else {
    Res = ERR_NOTAVAIL;                                    /* Endpoint is disabled */
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceCancelTransfer (component USB_LDD)
*/
/*!
**     @brief
**         Cancels all pending transfers in the given EP queue.
**         Transfer status is updated and callback function is called
**         for each cancelled transfer request if enabled in the
**         <SendData> or <RecvData> methods.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceCancelTransfer(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx OUT data structure */
  if (EpDir != LDD_USB_DIR_OUT) {                          /* EPx IN is next item in the array */
    EpDataPtr++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX + 0x01u]) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  Res = USB_LDD_DeviceAbortAllTransfers(DevDataPtr, EpDataPtr);
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceIsr (component USB_LDD)
**
**     Description :
**         Device mode interrupt handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceIsr(USB_LDD_TDeviceData *DevDataPtr, uint32_t InSignalsState)
{
  uint32_t                         IntStatus;
  uint32_t                         BDCtrlReg;
  uint16_t                         DataSize;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_USB_TSDP                    *SDPPtr;
  uint16_t                         FrameNumber;

  if (DevDataPtr->DeviceState >= LDD_USB_DEVICE_VBUS_OFF) { /* Device enabled and VBUS = ON? */
    if ((InSignalsState & USB_LDD_1MS_TIMEOUT) != 0x00U) {  /* 1ms timer interrupt? */
      /* 1ms interrupt handler */
      USB_LDD_OnDevice1msTimer(DevDataPtr->UserDeviceDataPtr);
    } /* 1ms */
    if ((InSignalsState & USB_LDD_TIMEOUT) != 0x00U) {      /* Timeout? */
      switch (DevDataPtr->DeviceState) {
        case LDD_USB_DEVICE_SUSPENDED:
          /* At this time the BUS is IDLE for at least 5ms and */
          /* device can generate wake-up signaling (if enabled by the Host) */
          DevDataPtr->DeviceState = LDD_USB_DEVICE_SUSPENDED_RESUME_READY; /* Remember new port state */
          break;
        case LDD_USB_DEVICE_SUSPENDED_RESUME_READY:
          USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_DISABLE);
          DevDataPtr->DeviceState = LDD_USB_DEVICE_ENABLED; /* Remember new port state */
          break;
        default:
          break;
      }
    }
    IntStatus = USB_PDD_GetUsbInterruptFlags(USB0_BASE_PTR);
    IntStatus &= USB_PDD_GetUsbInterruptMask(USB0_BASE_PTR);
    if (IntStatus == 0U) {
      return;
    }
    /* USB module error interrupt handler */
    if ((IntStatus & USB_PDD_ERROR_INT) != 0x00U) {         /* USB error detected? */
      USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, 0xFFU); /* Clear error flags */
      USB_PDD_ClearErrorInterruptFlag(USB0_BASE_PTR);       /* Clear "error" interrupt flag */
      USB_LDD_OnDeviceError(DevDataPtr->UserDeviceDataPtr, 0u, USB_PDD_GetErrorsInterruptFlags(USB0_BASE_PTR));
    }
    /* SOF packet received interrupt handler */
    if ((IntStatus & USB_PDD_SOF_TOK_INT) != 0x00U) {       /* SOF received? */
      USB_PDD_ClearSofInterruptFlag(USB0_BASE_PTR);         /* Clear "sof" interrupt flag */
      FrameNumber = (uint16_t)((uint16_t)(USB_PDD_GetFrameNumberHigh(USB0_BASE_PTR)) << 0x08); /* Get current frame number */
      FrameNumber |= (uint16_t)(USB_PDD_GetFrameNumberLow(USB0_BASE_PTR));
      USB_LDD_OnDeviceSof(DevDataPtr->UserDeviceDataPtr, FrameNumber);
    }
    if ((IntStatus & USB_PDD_TOK_DNE_INT) != 0x00U) {
      /* TOKE_DONE interrupt detected */
      EpDataPtr = &DevDataPtr->EpData[((uint32_t)(USB_PDD_ReadStatusReg(USB0_BASE_PTR))) >> 0x03];
      BDPtr = &DevDataPtr->BDT[((uint32_t)(USB_PDD_ReadStatusReg(USB0_BASE_PTR))) >> 0x02];
      EpDataPtr->LastTrBDPtr = BDPtr;
      BDCtrlReg = BDPtr->CtrlReg;
      DataSize = (uint16_t)(((uint32_t)BDCtrlReg >> 0x10U) & 0x03FFU);
      SDPPtr = (LDD_USB_TSDP*)BDPtr->BufferPtr;
      if (USB_PDD_GetTransmitIndicator(USB0_BASE_PTR)) {    /* Tx done? */
        USB_LDD_DeviceDataPacketDone(DevDataPtr, EpDataPtr, DataSize);
      } else {                                              /* Rx done */
        if ((BDCtrlReg & USB_LDD_BD_PID_MASK) == ((uint32_t)LDD_USB_PID_SETUP << 0x02)) { /* Setup packet? */
          (void)USB_LDD_DeviceAbortAllTransfers(DevDataPtr,EpDataPtr); /* New setup command, discard all pending transactions */
          (void)USB_LDD_DeviceAbortAllTransfers(DevDataPtr,EpDataPtr + 1U); /* New setup command, discard all pending transactions */
          EpDataPtr->BDCtrlRegVal |= USB_LDD_BD_DATA1;      /* The next transaction must be always IN/OUT DATA1 */
          (EpDataPtr + 1)->BDCtrlRegVal |= USB_LDD_BD_DATA1;
          if (SDPPtr->wLength == 0x00U) {
            /* No-data control transfer */
            EpDataPtr->TT.Ctrl.Stage=USB_LDD_CONTROL_NO_DATA; /* Rx - No data should be received */
            (EpDataPtr + 1U)->TT.Ctrl.Stage=USB_LDD_CONTROL_NO_DATA_HSK; /* Tx - Handshake should be sent */
          } else if ((SDPPtr->bmRequestType & LDD_USB_DIR_IN) != 0x00U) {
            /* Control read */
            EpDataPtr->TT.Ctrl.Stage=USB_LDD_CONTROL_READ_HSK; /* Rx - Handshake should be received */
            (EpDataPtr + 1U)->TT.Ctrl.Stage=USB_LDD_CONTROL_READ_DATA; /* Tx - Data should be sent */
          } else {
            /* Control write */
            EpDataPtr->TT.Ctrl.Stage=USB_LDD_CONTROL_WRITE_DATA; /* Rx - Data should be received */
            (EpDataPtr + 1U)->TT.Ctrl.Stage=USB_LDD_CONTROL_WRITE_HSK; /* Tx - Handshake should be sent */
          }
          USB_LDD_OnDeviceSetupPacket(DevDataPtr->UserDeviceDataPtr,  (uint8_t)EpDataPtr->EpNumber);
        } else {                                            /* Data packet */
          USB_LDD_DeviceDataPacketDone(DevDataPtr, EpDataPtr, DataSize);
        }
      }
      USB_PDD_ClearTokenDoneInterruptFlag(USB0_BASE_PTR);   /* Clear "token done" interrupt flag */
    } else {
      /* Some special interrupt detected and no token done is pending */
      if ((IntStatus & USB_PDD_USB_RST_INT) != 0x00U) {     /* USB Reset Signal detected? */
      /* USB Reset signal detected interrupt handler */
        /* Disable SW and HW access to all Endpoints */
        USB_LDD_DeviceDisableAllEp(DevDataPtr);
        USB_PDD_ClearBusResetInterruptFlag(USB0_BASE_PTR);  /* Clear "reset" interrupt flag */
        USB_PDD_WriteAddressReg(USB0_BASE_PTR, 0x00U);      /* Set device address to the 0 value */
        USB_PDD_ResetBdtPingPong(USB0_BASE_PTR);            /* Reset internal engine state */
        USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_DISABLE); /* Stop wake-up signaling (if enabled) */
        if (USB_PDD_GetDpPullUpSignalState(USB0_BASE_PTR)) { /* VBUS on? */
          USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_USB_RST_INT | USB_PDD_SLEEP_INT | USB_PDD_TOK_DNE_INT | USB_PDD_SOF_TOK_INT);
          DevDataPtr->DeviceState = LDD_USB_DEVICE_ENABLED; /* Remember new device state */
          USB_LDD_OnDeviceReset(DevDataPtr->UserDeviceDataPtr);
          USB_LDD_OnDeviceSpeedDetect(DevDataPtr->UserDeviceDataPtr, LDD_USB_FULL_SPEED);
          USB_LDD_DeviceReceiveSetupPacket(&DevDataPtr->EpData[0x00u]);
        } else {
          DevDataPtr->DeviceState = LDD_USB_DEVICE_VBUS_OFF;
        }
      } else if ((IntStatus & USB_PDD_RESUME_INT) != 0x00U) { /* Resume signaling detected? */
      /* Resume signal detected interrupt handler */
        USB_PDD_DisableResumeInterrupt(USB0_BASE_PTR);      /* Disable "resume" interrupt */
        USB_PDD_ClearResumeInterruptFlag(USB0_BASE_PTR);    /* Clear "resume" interrupt flag */
        DevDataPtr->DeviceState = DevDataPtr->LastDeviceState; /* Return to the previous state */
        USB_LDD_OnDeviceResume(DevDataPtr->UserDeviceDataPtr);
      } else if ((IntStatus & USB_PDD_SLEEP_INT) != 0x00U) { /* Suspend detected (Idle more then 3 ms)? */
      /* Suspend detected interrupt handler */
        USB_PDD_ClearSuspendInterruptFlag(USB0_BASE_PTR);   /* Clear "suspend" interrupt flag */
        USB_PDD_ClearResumeInterruptFlag(USB0_BASE_PTR);    /* Clear "resume" interrupt flag */
        USB_PDD_EnableResumeInterrupt(USB0_BASE_PTR);       /* Enable "resume" interrupt */
        DevDataPtr->LastDeviceState = DevDataPtr->DeviceState; /* Remember current device state */
        DevDataPtr->DeviceState = LDD_USB_DEVICE_SUSPENDED; /* Set new device state state */
        DevDataPtr->msCounter = 3;                          /* Prepare to wait at 2 ms from IDLE before forcing resume */
        USB_PDD_Enable1msInterrupt(USB0_BASE_PTR);          /* Enable 1 ms interrupt */
        USB_LDD_OnDeviceSuspend(DevDataPtr->UserDeviceDataPtr);
      } else {
        ;
      }
    }
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_USB_Interrupt (component USB_LDD)
**
**     Description :
**         USB interrupt handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(USB_LDD_USB_Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  USB_LDD_TDeviceDataPtr DevDataPtr = INT_USB0__DEFAULT_RTOS_ISRPARAM;
  uint32_t NewInSignalState;
  uint32_t OtgIntStatus;
  
  DevDataPtr->ISR = TRUE;
  OtgIntStatus = USB_PDD_GetOtgInterruptFlags(USB0_BASE_PTR);
  OtgIntStatus &= USB_PDD_GetOtgInterruptMask(USB0_BASE_PTR);
  USB_PDD_ClearOtgInterruptFlags(USB0_BASE_PTR, OtgIntStatus);
  NewInSignalState = DevDataPtr->InSignalsState;           /* Get current signal state */
  if ((OtgIntStatus & USB_PDD_1_MSEC_INT) != 0U) {         /* 1ms timer interrupt? */
    NewInSignalState |= USB_LDD_1MS_TIMEOUT;               /* Remember timeout */
    if (DevDataPtr->msCounter > 0x00) {                    /* Otg timing in progress? */
      DevDataPtr->msCounter--;                             /* Decrement 1 ms counter */
      if (DevDataPtr->msCounter == 0x00 ) {                /* Timing done? */
        NewInSignalState |= USB_LDD_TIMEOUT;               /* Remember timeout */
      }
    }
  } /* 1 ms interrupt */
  USB_LDD_DeviceIsr(DevDataPtr, NewInSignalState);         /* Call interrupt handler */
  DevDataPtr->ISR = FALSE;
}


/* END USB_LDD. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.08]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
